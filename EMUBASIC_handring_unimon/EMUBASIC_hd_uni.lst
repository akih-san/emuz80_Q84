0000                    ;	EMUBASIC based on GRANT's BASIC
0000                    ;	TARGET: EMUZ80
0000                    ;	ASSEMBLER: ARCPIT XZ80.EXE
0000                    ;
0000                    ;	START UP ROUTINE
0000                    ;	VERSION 1.0, 2022/02/15
0000                    ;	WRITTEN by TETSUYA SUZUKI
0000                    ;	Modified Akihito Honda
0000                    ;		UART 0FF00H - FF01H
0000                    ;
0000                    ;	MEMORY ASIGN
1000                    ROMTOP	EQU	1000H		; 0000H - 0FFFH for unimon
C000                    RAMTOP	EQU	0C000H
3000                    RAMSIZ	EQU	3000H
0000                    ;
0000                    ;	UART REGISTER ADDRESS
FF00                    UARTDR	EQU	0FF00H	; UART DATA REGISTOR
FF01                    UARTCR	EQU	0FF01H	; UART CONTROL REGISTOR
0000
0000                    ; Universal Monitor WSTART
0003                    UNI_WST	EQU	0003H
0000
0000                    ;
0000                    ;	RESET (RST 00H)
0000                    	ORG	ROMTOP
1000    C3 41 10        	JP	STARTB		; Jump for cold start
1003    C3 B6 10        	JP	WARMST		; Jump for warm start
1006                    ;
1006                    ;	PUT 1CHAR (RST 08H)
1006                    ;	ORG	ROMTOP+08H
1006    00 00           	ds	ROMTOP+08H - $, 0x00
1008    C3 34 10        	JP	TXA
100B                    ;
100B                    ;	GET 1CHAR (RST 10H)
100B                    ;	ORG	ROMTOP+10H
100B    00 00 00 00     	ds	ROMTOP+10H - $, 0x00
100F    00
1010    C3 1B 10        	JP	RXA
1013                    ;
1013                    ;	KBHIT (RST 18H)
1013                    ;	ORG	ROMTOP+18H
1013    00 00 00 00     	ds	ROMTOP+18H - $, 0x00
1017    00
1018    C3 2E 10        	JP	KBHIT
101B                    ;
101B                    ;	UART -> A
101B    3A 01 FF        RXA:	LD	A,(UARTCR)
101E    CB 47           	BIT	0,A
1020    28 F9           	JR	Z,RXA
1022    3A 00 FF        	LD	A,(UARTDR)
1025    FE 61           	CP	'a'
1027    D8              	RET	C
1028    FE 7B           	CP	'z'+1
102A    D0              	RET	NC
102B    E6 DF           	AND	0DFH
102D    C9              	RET
102E                    ;
102E                    ;	CHECK RECEIVE STATUS
102E    3A 01 FF        KBHIT:	LD	A,(UARTCR)
1031    CB 47           	BIT	0,A
1033    C9              	RET
1034                    ;
1034                    ;	A -> UART
1034    F5              TXA:	PUSH	AF
1035    3A 01 FF        TXAST1:	LD	A,(UARTCR)
1038    CB 4F           	BIT	1,A
103A    28 F9           	JR	Z,TXAST1
103C    F1              	POP	AF
103D    32 00 FF        	LD	(UARTDR),A
1040    C9              	RET
1041                    ;
1041                    ;==================================================================================
1041                    ; The updates to the original BASIC within this file are copyright Grant Searle
1041                    ;
1041                    ; You have permission to use this for NON COMMERCIAL USE ONLY
1041                    ; If you wish to use it elsewhere, please include an acknowledgement to myself.
1041                    ;
1041                    ; http://searle.hostei.com/grant/index.html
1041                    ;
1041                    ; eMail: home.micros01@btinternet.com
1041                    ;
1041                    ; If the above don't work, please perform an Internet search to see if I have
1041                    ; updated the web page hosting service.
1041                    ;
1041                    ;==================================================================================
1041                    ;
1041                    ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
1041                    ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
1041                    ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
1041                    ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
1041                    ; the original ROM code (checksum A934H). PA
1041                    ;
1041                    ; GENERAL EQUATES
1041                    ;
0003                    CTRLC	EQU	03H		; Control "C"
0007                    CTRLG	EQU	07H		; Control "G"
0008                    BKSP	EQU	08H		; Back space
000A                    LF	EQU	0AH		; Line feed
000C                    CS	EQU	0CH		; Clear screen
000D                    CR	EQU	0DH		; Carriage return
000F                    CTRLO	EQU	0FH		; Control "O"
0011                    CTRLQ	EQU	11H		; Control "Q"
0012                    CTRLR	EQU	12H		; Control "R"
0013                    CTRLS	EQU	13H		; Control "S"
0015                    CTRLU	EQU	15H		; Control "U"
001B                    ESC	EQU	1BH		; Escape
007F                    DEL	EQU	7FH		; Delete
1041                    ;
1041                    ; BASIC WORK SPACE LOCATIONS
1041                    ;
C045                    WRKSPC	EQU	RAMTOP + 45H	; BASIC Work space
C048                    USR	EQU	WRKSPC+3H	; "USR (x)" jump
C04B                    OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
C04C                    OTPORT	EQU	WRKSPC+7H	; Port (p)
C04E                    DIVSUP	EQU	WRKSPC+9H	; Division support routine
C04F                    DIV1	EQU	WRKSPC+0AH	; <- Values
C053                    DIV2	EQU	WRKSPC+0EH	; <- to
C057                    DIV3	EQU	WRKSPC+12H	; <- be
C05A                    DIV4	EQU	WRKSPC+15H	; <- inserted
C05C                    SEED	EQU	WRKSPC+17H	; Random number seed
C07F                    LSTRND	EQU	WRKSPC+3AH	; Last random number
C083                    INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
C084                    INPORT	EQU	WRKSPC+3FH	; PORT (x)
C086                    NULLS	EQU	WRKSPC+41H	; Number of nulls
C087                    LWIDTH	EQU	WRKSPC+42H	; Terminal width
C088                    COMMAN	EQU	WRKSPC+43H	; Width for commas
C089                    NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
C08A                    CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
C08B                    LINESC	EQU	WRKSPC+46H	; Lines counter
C08D                    LINESN	EQU	WRKSPC+48H	; Lines number
C08F                    CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
C091                    NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
C092                    BRKFLG	EQU	WRKSPC+4DH	; Break flag
C093                    RINPUT	EQU	WRKSPC+4EH	; Input reflection
C096                    POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
C099                    PSET	EQU	WRKSPC+54H	; "SET"	reflection
C09C                    RESET	EQU	WRKSPC+57H	; "RESET" reflection
C09F                    STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
C0A1                    LINEAT	EQU	WRKSPC+5CH	; Current line number
C0A3                    BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
C0A6                    BUFFER	EQU	WRKSPC+61H	; Input buffer
C0AB                    STACK	EQU	WRKSPC+66H	; Initial stack
C0F0                    CURPOS	EQU	WRKSPC+0ABH	; Character position on line
C0F1                    LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
C0F2                    TYPE	EQU	WRKSPC+0ADH	; Data type flag
C0F3                    DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
C0F4                    LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
C0F6                    TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
C0F8                    TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
C104                    TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
C108                    STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
C10A                    CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
C10C                    LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
C10E                    DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
C110                    FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
C111                    LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
C112                    READFG	EQU	WRKSPC+0CDH	; Read/Input flag
C113                    BRKLIN	EQU	WRKSPC+0CEH	; Line of break
C115                    NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
C117                    ERRLIN	EQU	WRKSPC+0D2H	; Line of error
C119                    CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
C11B                    PROGND	EQU	WRKSPC+0D6H	; End of program
C11D                    VAREND	EQU	WRKSPC+0D8H	; End of variables
C11F                    ARREND	EQU	WRKSPC+0DAH	; End of arrays
C121                    NXTDAT	EQU	WRKSPC+0DCH	; Next data item
C123                    FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
C125                    FNARG	EQU	WRKSPC+0E0H	; FN argument value
C129                    FPREG	EQU	WRKSPC+0E4H	; Floating point register
C12C                    FPEXP	EQU	FPREG+3		; Floating point exponent
C12D                    SGNRES	EQU	WRKSPC+0E8H	; Sign of result
C12E                    PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
C13B                    MULVAL	EQU	WRKSPC+0F6H	; Multiplier
C13E                    PROGST	EQU	WRKSPC+0F9H	; Start of program text area
C1A2                    STLOOK	EQU	WRKSPC+15DH	; Start of memory test
1041                    ;
1041                    ; BASIC ERROR CODE VALUES
1041                    ;
0000                    NF	EQU	00H		; NEXT without FOR
0002                    SN	EQU	02H		; Syntax error
0004                    RG	EQU	04H		; RETURN without GOSUB
0006                    OD	EQU	06H		; Out of DATA
0008                    FC	EQU	08H		; Function call error
000A                    OV	EQU	0AH		; Overflow
000C                    OM	EQU	0CH		; Out of memory
000E                    UL	EQU	0EH		; Undefined line number
0010                    BS	EQU	10H		; Bad subscript
0012                    RD	EQU	12H		; Re-DIMensioned array
0014                    DZ	EQU	14H		; Division by zero (/0)
0016                    ID	EQU	16H		; Illegal direct
0018                    TM	EQU	18H		; Type miss-match
001A                    OS	EQU	1AH		; Out of string space
001C                    LS	EQU	1CH		; String too long
001E                    ST	EQU	1EH		; String formula too complex
0020                    CN	EQU	20H		; Can't CONTinue
0022                    UF	EQU	22H		; UnDEFined FN function
0024                    MO	EQU	24H		; Missing operand
0026                    HX	EQU	26H		; HEX error
0028                    BN	EQU	28H		; BIN error
1041                    ;
1041    C3 48 10        STARTB: JP	CSTART		; Jump to initialise
1044                    ;
1044    F9 18           	DW	DEINT		; Get integer -32768 to 32767
1046    6F 20           	DW	ABPASS		; Return integer in AB
1048                    ;
1048    21 45 C0        CSTART: LD	HL,WRKSPC	; Start of workspace RAM
104B    F9              	LD	SP,HL		; Set up a temporary stack
104C    C3 8A 2C        	JP	INITST		; Go to initialise
104F                    ;
104F    11 20 13        INIT:	LD	DE,INITAB	; Initialise workspace
1052    06 63           	LD	B,INITBE-INITAB+3; Bytes to copy
1054    21 45 C0        	LD	HL,WRKSPC	; Into workspace RAM
1057    1A              COPY:	LD	A,(DE)		; Get source
1058    77              	LD	(HL),A		; To destination
1059    23              	INC	HL		; Next destination
105A    13              	INC	DE		; Next source
105B    05              	DEC	B		; Count bytes
105C    C2 57 10        	JP	NZ,COPY		; More to move
105F    F9              	LD	SP,HL		; Temporary stack
1060    CD 21 15        	CALL	CLREG		; Clear registers and stack
1063    CD EF 1A        	CALL	PRCRLF		; Output CRLF
1066    32 EF C0        	LD	(BUFFER+72+1),A	; Mark end of buffer
1069    32 3E C1        	LD	(PROGST),A	; Initialise program area
106C    21 A2 C1        MSIZE:	LD	HL,STLOOK	; Point to start of RAM
106F    23              MLOOP:	INC	HL		; Next byte
1070    7C              	LD	A,H		; Above address FFFF ?
1071    B5              	OR	L
1072    CA 7E 10        	JP	Z,SETTOP	; Yes - 64K RAM
1075    7E              	LD	A,(HL)		; Get contents
1076    47              	LD	B,A		; Save it
1077    2F              	CPL			; Flip all bits
1078    77              	LD	(HL),A		; Put it back
1079    BE              	CP	(HL)		; RAM there if same
107A    70              	LD	(HL),B		; Restore old contents
107B    CA 6F 10        	JP	Z,MLOOP		; If RAM - test next byte
107E                    ;
107E    2B              SETTOP: DEC	HL		; Back one byte
107F    11 A1 C1        	LD	DE,STLOOK-1	; See if enough RAM
1082    CD B7 16        	CALL	CPDEHL		; Compare DE with HL
1085    DA BF 10        	JP	C,NEMEM		; If not enough RAM
1088    11 CE FF        	LD	DE,0-50		; 50 Bytes string space
108B    22 F4 C0        	LD	(LSTRAM),HL	; Save last available RAM
108E    19              	ADD	HL,DE		; Allocate string space
108F    22 9F C0        	LD	(STRSPC),HL	; Save string space
1092    CD FC 14        	CALL	CLRPTR		; Clear program area
1095    2A 9F C0        	LD	HL,(STRSPC)	; Get end of memory
1098    11 EF FF        	LD	DE,0-17		; Offset for free bytes
109B    19              	ADD	HL,DE		; Adjust HL
109C    11 3E C1        	LD	DE,PROGST	; Start of program text
109F    7D              	LD	A,L		; Get LSB
10A0    93              	SUB	E		; Adjust it
10A1    6F              	LD	L,A		; Re-save
10A2    7C              	LD	A,H		; Get MSB
10A3    9A              	SBC	A,D		; Adjust it
10A4    67              	LD	H,A		; Re-save
10A5    E5              	PUSH	HL		; Save bytes free
10A6    21 D7 10        	LD	HL,SIGNON	; Sign-on message
10A9    CD 8D 21        	CALL	PRS		; Output string
10AC    E1              	POP	HL		; Get bytes free back
10AD    CD 30 28        	CALL	PRNTHL		; Output amount of free memory
10B0    21 C8 10        	LD	HL,BFREE	; " Bytes free" message
10B3    CD 8D 21        	CALL	PRS		; Output string
10B6                    ;
10B6    31 AB C0        WARMST: LD	SP,STACK	; Temporary stack
10B9    CD 21 15        BRKRET: CALL	CLREG		; Clear registers and stack
10BC    C3 3A 14        	JP	PRNTOK		; Go to get command line
10BF                    ;
10BF    21 0E 11        NEMEM:	LD	HL,MEMMSG	; Memory size not enough
10C2    CD 8D 21        	CALL	PRS		; Print it
10C5    C3 C5 10        XXXXX:	JP	XXXXX		; Stop
10C8                    ;
10C8    20 42 79 74     BFREE:	DB	" Bytes free",CR,LF,0,0
10CC    65 73 20 66
10D0    72 65 65 0D
10D4    0A 00 00
10D7                    ;
10D7    5A 38 30 20     SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
10DB    42 41 53 49
10DF    43 20 56 65
10E3    72 20 34 2E
10E7    37 62 0D 0A
10EB    43 6F 70 79     	DB	"Copyright ",40,"C",41
10EF    72 69 67 68
10F3    74 20 28 43
10F7    29
10F8    20 31 39 37     	DB	" 1978 by Microsoft",CR,LF,0,0
10FC    38 20 62 79
1100    20 4D 69 63
1104    72 6F 73 6F
1108    66 74 0D 0A
110C    00 00
110E                    ;
110E    4D 65 6D 6F     MEMMSG: DB	"Memory size not enough",CR,LF
1112    72 79 20 73
1116    69 7A 65 20
111A    6E 6F 74 20
111E    65 6E 6F 75
1122    67 68 0D 0A
1126    54 68 65 20     	DB	"The system is stopped.",CR,LF,0,0
112A    73 79 73 74
112E    65 6D 20 69
1132    73 20 73 74
1136    6F 70 70 65
113A    64 2E 0D 0A
113E    00 00
1140                    ;
1140                    ; FUNCTION ADDRESS TABLE
1140                    ;
1140    A5 26           FNCTAB: DW	SGN
1142    69 27           	DW	INT
1144    BB 26           	DW	ABS
1146    48 C0           	DW	USR
1148    4D 20           	DW	FRE
114A    D2 23           	DW	INP
114C    7B 20           	DW	POS
114E    2F 29           	DW	SQR
1150    0E 2A           	DW	RND
1152    4A 25           	DW	LOG
1154    7D 29           	DW	EXP
1156    83 2A           	DW	COS
1158    89 2A           	DW	SIN
115A    EA 2A           	DW	TAN
115C    FF 2A           	DW	ATN
115E    26 24           	DW	PEEK
1160    6A 2B           	DW	DEEK
1162    96 C0           	DW	POINT
1164    FF 22           	DW	LEN
1166    17 21           	DW	STR
1168    99 23           	DW	VAL
116A    0E 23           	DW	ASC
116C    1F 23           	DW	CHR
116E    8C 2B           	DW	HEX
1170    1F 2C           	DW	BIN
1172    2F 23           	DW	LEFT
1174    5F 23           	DW	RIGHT
1176    69 23           	DW	MID
1178                    ;
1178                    ; RESERVED WORD LIST
1178                    ;
1178    C5 4E 44        WORDS:	DB	0C5H,"ND"
117B    C6 4F 52        	DB	0C6H,"OR"
117E    CE 45 58 54     	DB	0CEH,"EXT"
1182    C4 41 54 41     	DB	0C4H,"ATA"
1186    C9 4E 50 55     	DB	0C9H,"NPUT"
118A    54
118B    C4 49 4D        	DB	0C4H,"IM"
118E    D2 45 41 44     	DB	0D2H,"EAD"
1192    CC 45 54        	DB	0CCH,"ET"
1195    C7 4F 54 4F     	DB	0C7H,"OTO"
1199    D2 55 4E        	DB	0D2H,"UN"
119C    C9 46           	DB	0C9H,"F"
119E    D2 45 53 54     	DB	0D2H,"ESTORE"
11A2    4F 52 45
11A5    C7 4F 53 55     	DB	0C7H,"OSUB"
11A9    42
11AA    D2 45 54 55     	DB	0D2H,"ETURN"
11AE    52 4E
11B0    D2 45 4D        	DB	0D2H,"EM"
11B3    D3 54 4F 50     	DB	0D3H,"TOP"
11B7    CF 55 54        	DB	0CFH,"UT"
11BA    CF 4E           	DB	0CFH,"N"
11BC    CE 55 4C 4C     	DB	0CEH,"ULL"
11C0    D7 41 49 54     	DB	0D7H,"AIT"
11C4    C4 45 46        	DB	0C4H,"EF"
11C7    D0 4F 4B 45     	DB	0D0H,"OKE"
11CB    C4 4F 4B 45     	DB	0C4H,"OKE"
11CF    D3 43 52 45     	DB	0D3H,"CREEN"
11D3    45 4E
11D5    CC 49 4E 45     	DB	0CCH,"INES"
11D9    53
11DA    C3 4C 53        	DB	0C3H,"LS"
11DD    D7 49 44 54     	DB	0D7H,"IDTH"
11E1    48
11E2    CD 4F 4E 49     	DB	0CDH,"ONITOR"
11E6    54 4F 52
11E9    D3 45 54        	DB	0D3H,"ET"
11EC    D2 45 53 45     	DB	0D2H,"ESET"
11F0    54
11F1    D0 52 49 4E     	DB	0D0H,"RINT"
11F5    54
11F6    C3 4F 4E 54     	DB	0C3H,"ONT"
11FA    CC 49 53 54     	DB	0CCH,"IST"
11FE    C3 4C 45 41     	DB	0C3H,"LEAR"
1202    52
1203    C3 4C 4F 41     	DB	0C3H,"LOAD"
1207    44
1208    C3 53 41 56     	DB	0C3H,"SAVE"
120C    45
120D    CE 45 57        	DB	0CEH,"EW"
1210                    ;
1210    D4 41 42 28     	DB	0D4H,"AB("
1214    D4 4F           	DB	0D4H,"O"
1216    C6 4E           	DB	0C6H,"N"
1218    D3 50 43 28     	DB	0D3H,"PC("
121C    D4 48 45 4E     	DB	0D4H,"HEN"
1220    CE 4F 54        	DB	0CEH,"OT"
1223    D3 54 45 50     	DB	0D3H,"TEP"
1227                    ;
1227    AB              	DB	0ABH
1228    AD              	DB	0ADH
1229    AA              	DB	0AAH
122A    AF              	DB	0AFH
122B    DE              	DB	0DEH
122C    C1 4E 44        	DB	0C1H,"ND"
122F    CF 52           	DB	0CFH,"R"
1231    BE              	DB	0BEH
1232    BD              	DB	0BDH
1233    BC              	DB	0BCH
1234                    ;
1234    D3 47 4E        	DB	0D3H,"GN"
1237    C9 4E 54        	DB	0C9H,"NT"
123A    C1 42 53        	DB	0C1H,"BS"
123D    D5 53 52        	DB	0D5H,"SR"
1240    C6 52 45        	DB	0C6H,"RE"
1243    C9 4E 50        	DB	0C9H,"NP"
1246    D0 4F 53        	DB	0D0H,"OS"
1249    D3 51 52        	DB	0D3H,"QR"
124C    D2 4E 44        	DB	0D2H,"ND"
124F    CC 4F 47        	DB	0CCH,"OG"
1252    C5 58 50        	DB	0C5H,"XP"
1255    C3 4F 53        	DB	0C3H,"OS"
1258    D3 49 4E        	DB	0D3H,"IN"
125B    D4 41 4E        	DB	0D4H,"AN"
125E    C1 54 4E        	DB	0C1H,"TN"
1261    D0 45 45 4B     	DB	0D0H,"EEK"
1265    C4 45 45 4B     	DB	0C4H,"EEK"
1269    D0 4F 49 4E     	DB	0D0H,"OINT"
126D    54
126E    CC 45 4E        	DB	0CCH,"EN"
1271    D3 54 52 24     	DB	0D3H,"TR$"
1275    D6 41 4C        	DB	0D6H,"AL"
1278    C1 53 43        	DB	0C1H,"SC"
127B    C3 48 52 24     	DB	0C3H,"HR$"
127F    C8 45 58 24     	DB	0C8H,"EX$"
1283    C2 49 4E 24     	DB	0C2H,"IN$"
1287    CC 45 46 54     	DB	0CCH,"EFT$"
128B    24
128C    D2 49 47 48     	DB	0D2H,"IGHT$"
1290    54 24
1292    CD 49 44 24     	DB	0CDH,"ID$"
1296    80              	DB	80H		; End of list marker
1297                    ;
1297                    ; KEYWORD ADDRESS TABLE
1297                    ;
1297    91 18           WORDTB: DW	PEND
1299    8E 17           	DW	FOR
129B    69 1C           	DW	NEXT
129D    DE 19           	DW	DATA
129F    70 1B           	DW	INPUT
12A1    A5 1E           	DW	DIM
12A3    9F 1B           	DW	READ
12A5    F5 19           	DW	LET
12A7    9B 19           	DW	GOTO
12A9    7E 19           	DW	RUN
12AB    6D 1A           	DW	IF_
12AD    57 18           	DW	RESTOR
12AF    8A 19           	DW	GOSUB
12B1    B9 19           	DW	RETURN
12B3    E0 19           	DW	REM
12B5    8F 18           	DW	STOP
12B7    DE 23           	DW	POUT
12B9    4F 1A           	DW	ON
12BB    D0 18           	DW	NULL
12BD    E4 23           	DW	WAIT
12BF    83 20           	DW	DEF
12C1    2D 24           	DW	POKE
12C3    75 2B           	DW	DOKE
12C5    E0 19           	DW	REM
12C7    5B 2B           	DW	LINES
12C9    4E 2B           	DW	CLS
12CB    53 2B           	DW	WIDTH
12CD    87 2C           	DW	MONITR
12CF    99 C0           	DW	PSET
12D1    9C C0           	DW	RESET
12D3    91 1A           	DW	PRINT
12D5    BD 18           	DW	CONT
12D7    03 17           	DW	LIST
12D9    38 19           	DW	CLEAR
12DB    E0 19           	DW	REM
12DD    E0 19           	DW	REM
12DF    FB 14           	DW	NEW
12E1                    ;
12E1                    ; RESERVED WORD TOKEN VALUES
12E1                    ;
0080                    ZEND	EQU	080H		; END
0081                    ZFOR	EQU	081H		; FOR
0083                    ZDATA	EQU	083H		; DATA
0088                    ZGOTO	EQU	088H		; GOTO
008C                    ZGOSUB	EQU	08CH		; GOSUB
008E                    ZREM	EQU	08EH		; REM
009E                    ZPRINT	EQU	09EH		; PRINT
00A4                    ZNEW	EQU	0A4H		; NEW
12E1                    ;
00A5                    ZTAB	EQU	0A5H		; TAB
00A6                    ZTO	EQU	0A6H		; TO
00A7                    ZFN	EQU	0A7H		; FN
00A8                    ZSPC	EQU	0A8H		; SPC
00A9                    ZTHEN	EQU	0A9H		; THEN
00AA                    ZNOT	EQU	0AAH		; NOT
00AB                    ZSTEP	EQU	0ABH		; STEP
12E1                    ;
00AC                    ZPLUS	EQU	0ACH		; +
00AD                    ZMINUS	EQU	0ADH		; -
00AE                    ZTIMES	EQU	0AEH		; *
00AF                    ZDIV	EQU	0AFH		; /
00B2                    ZOR	EQU	0B2H		; OR
00B3                    ZGTR	EQU	0B3H		; >
00B4                    ZEQUAL	EQU	0B4H		; M
00B5                    ZLTH	EQU	0B5H		; <
00B6                    ZSGN	EQU	0B6H		; SGN
00C7                    ZPOINT	EQU	0C7H		; POINT
00CF                    ZLEFT	EQU	0CDH +2		; LEFT$
12E1                    ;
12E1                    ; ARITHMETIC PRECEDENCE TABLE
12E1                    ;
12E1    79              PRITAB: DB	79H		; Precedence value
12E2    17 28           	DW	PADD		; FPREG = <last> + FPREG
12E4                    ;
12E4    79              	DB	79H		; Precedence value
12E5    4B 24           	DW	PSUB		; FPREG = <last> - FPREG
12E7                    ;
12E7    7C              	DB	7CH		; Precedence value
12E8    89 25           	DW	MULT		; PPREG = <last> * FPREG
12EA                    ;
12EA    7C              	DB	7CH		; Precedence value
12EB    EA 25           	DW	DIV		; FPREG = <last> / FPREG
12ED                    ;
12ED    7F              	DB	7FH		; Precedence value
12EE    38 29           	DW	POWER		; FPREG = <last> ^ FPREG
12F0                    ;
12F0    50              	DB	50H		; Precedence value
12F1    FE 1D           	DW	PAND		; FPREG = <last> AND FPREG
12F3                    ;
12F3    46              	DB	46H		; Precedence value
12F4    FD 1D           	DW	POR		; FPREG = <last> OR FPREG
12F6                    ;
12F6                    ; BASIC ERROR CODE LIST
12F6                    ;
12F6    4E 46           ERRORS: DB	"NF"		; NEXT without FOR
12F8    53 4E           	DB	"SN"		; Syntax error
12FA    52 47           	DB	"RG"		; RETURN without GOSUB
12FC    4F 44           	DB	"OD"		; Out of DATA
12FE    46 43           	DB	"FC"		; Illegal function call
1300    4F 56           	DB	"OV"		; Overflow error
1302    4F 4D           	DB	"OM"		; Out of memory
1304    55 4C           	DB	"UL"		; Undefined line
1306    42 53           	DB	"BS"		; Bad subscript
1308    44 44           	DB	"DD"		; Re-DIMensioned array
130A    2F 30           	DB	"/0"		; Division by zero
130C    49 44           	DB	"ID"		; Illegal direct
130E    54 4D           	DB	"TM"		; Type mis-match
1310    4F 53           	DB	"OS"		; Out of string space
1312    4C 53           	DB	"LS"		; String too long
1314    53 54           	DB	"ST"		; String formula too complex
1316    43 4E           	DB	"CN"		; Can't CONTinue
1318    55 46           	DB	"UF"		; Undefined FN function
131A    4D 4F           	DB	"MO"		; Missing operand
131C    48 58           	DB	"HX"		; HEX error
131E    42 4E           	DB	"BN"		; BIN error
1320                    ;
1320                    ; INITIALISATION TABLE -------------------------------------------------------
1320                    ;
1320    C3 B6 10        INITAB: JP	WARMST		; Warm start jump
1323    C3 0E 19        	JP	FCERR		; "USR (X)" jump (Set to Error)
1326    D3 00           	OUT	(0),A		; "OUT p,n" skeleton
1328    C9              	RET
1329    D6 00           	SUB	0		; Division support routine
132B    6F              	LD	L,A
132C    7C              	LD	A,H
132D    DE 00           	SBC	A,0
132F    67              	LD	H,A
1330    78              	LD	A,B
1331    DE 00           	SBC	A,0
1333    47              	LD	B,A
1334    3E 00           	LD	A,0
1336    C9              	RET
1337    00 00 00        	DB	0,0,0			; Random number seed table used by RND
133A    35 4A CA 99     	DB	035H,04AH,0CAH,099H	;-2.65145E+07
133E    39 1C 76 98     	DB	039H,01CH,076H,098H	; 1.61291E+07
1342    22 95 B3 98     	DB	022H,095H,0B3H,098H	;-1.17691E+07
1346    0A DD 47 98     	DB	00AH,0DDH,047H,098H	; 1.30983E+07
134A    53 D1 99 99     	DB	053H,0D1H,099H,099H	;-2-01612E+07
134E    0A 1A 9F 98     	DB	00AH,01AH,09FH,098H	;-1.04269E+07
1352    65 BC CD 98     	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
1356    D6 77 3E 98     	DB	0D6H,077H,03EH,098H	; 1.24825E+07
135A    52 C7 4F 80     	DB	052H,0C7H,04FH,080H	; Last random number
135E    DB 00           	IN	A,(0)		; INP (x) skeleton
1360    C9              	RET
1361    01              	DB	1		; POS (x) number (1)
1362    FF              	DB	255		; Terminal width (255 = no auto CRLF)
1363    1C              	DB	28		; Width for commas (3 columns)
1364    00              	DB	0		; No nulls after input bytes
1365    00              	DB	0		; Output enabled (^O off)
1366    14 00           	DW	20		; Initial lines counter
1368    14 00           	DW	20		; Initial lines number
136A    00 00           	DW	0		; Array load/save check sum
136C    00              	DB	0		; Break not by NMI
136D    00              	DB	0		; Break flag
136E    C3 34 16        	JP	TTYLIN		; Input reflection (set to TTY)
1371    C3 00 00        	JP	0000H		; POINT reflection unused
1374    C3 00 00        	JP	0000H		; SET reflection
1377    C3 00 00        	JP	0000H			; RESET reflection
137A    A2 C1           	DW	STLOOK		; Temp string space
137C    FE FF           	DW	-2		; Current line number (cold)
137E    3F C1           	DW	PROGST+1	; Start of program text
1380                    INITBE:
1380                    ;
1380                    ; END OF INITIALISATION TABLE ---------------------------------------------------
1380                    ;
1380    20 45 72 72     ERRMSG: DB	" Error",0
1384    6F 72 00
1387    20 69 6E 20     INMSG:	DB	" in ",0
138B    00
138B                    ZERBYT	EQU	$-1		; A zero byte
138C    4F 6B 0D 0A     OKMSG:	DB	"Ok",CR,LF,0,0
1390    00 00
1392    42 72 65 61     BRKMSG: DB	"Break",0
1396    6B 00
1398                    ;
1398    21 04 00        BAKSTK: LD	HL,4		; Look for "FOR" block with
139B    39              	ADD	HL,SP		; same index as specified
139C    7E              LOKFOR: LD	A,(HL)		; Get block ID
139D    23              	INC	HL		; Point to index address
139E    FE 81           	CP	ZFOR		; Is it a "FOR" token
13A0    C0              	RET	NZ		; No - exit
13A1    4E              	LD	C,(HL)		; BC = Address of "FOR" index
13A2    23              	INC	HL
13A3    46              	LD	B,(HL)
13A4    23              	INC	HL		; Point to sign of STEP
13A5    E5              	PUSH	HL		; Save pointer to sign
13A6    69              	LD	L,C		; HL = address of "FOR" index
13A7    60              	LD	H,B
13A8    7A              	LD	A,D		; See if an index was specified
13A9    B3              	OR	E		; DE = 0 if no index specified
13AA    EB              	EX	DE,HL		; Specified index into HL
13AB    CA B2 13        	JP	Z,INDFND	; Skip if no index given
13AE    EB              	EX	DE,HL		; Index back into DE
13AF    CD B7 16        	CALL	CPDEHL		; Compare index with one given
13B2    01 0D 00        INDFND: LD	BC,16-3		; Offset to next block
13B5    E1              	POP	HL		; Restore pointer to sign
13B6    C8              	RET	Z		; Return if block found
13B7    09              	ADD	HL,BC		; Point to next block
13B8    C3 9C 13        	JP	LOKFOR		; Keep on looking
13BB                    ;
13BB    CD D5 13        MOVUP:	CALL	ENFMEM		; See if enough memory
13BE    C5              MOVSTR: PUSH	BC		; Save end of source
13BF    E3              	EX	(SP),HL		; Swap source and dest" end
13C0    C1              	POP	BC		; Get end of destination
13C1    CD B7 16        MOVLP:	CALL	CPDEHL		; See if list moved
13C4    7E              	LD	A,(HL)		; Get byte
13C5    02              	LD	(BC),A		; Move it
13C6    C8              	RET	Z		; Exit if all done
13C7    0B              	DEC	BC		; Next byte to move to
13C8    2B              	DEC	HL		; Next byte to move
13C9    C3 C1 13        	JP	MOVLP		; Loop until all bytes moved
13CC                    ;
13CC    E5              CHKSTK: PUSH	HL		; Save code string address
13CD    2A 1F C1        	LD	HL,(ARREND)	; Lowest free memory
13D0    06 00           	LD	B,0		; BC = Number of levels to test
13D2    09              	ADD	HL,BC		; 2 Bytes for each level
13D3    09              	ADD	HL,BC
13D4    3E              	DB	3EH		; Skip "PUSH HL"
13D5    E5              ENFMEM: PUSH	HL		; Save code string address
13D6    3E D0           	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
13D8    95              	SUB	L
13D9    6F              	LD	L,A
13DA    3E FF           	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
13DC    9C              	SBC	A,H
13DD    DA E4 13        	JP	C,OMERR		; Not enough - ?OM Error
13E0    67              	LD	H,A
13E1    39              	ADD	HL,SP		; Test if stack is overflowed
13E2    E1              	POP	HL		; Restore code string address
13E3    D8              	RET	C		; Return if enough mmory
13E4    1E 0C           OMERR:	LD	E,OM		; ?OM Error
13E6    C3 03 14        	JP	ERROR_
13E9                    ;
13E9    2A 0E C1        DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
13EC    22 A1 C0        	LD	(LINEAT),HL	; Save as current line
13EF    1E 02           SNERR:	LD	E,SN		; ?SN Error
13F1    01              	DB	01H		; Skip "LD E,DZ"
13F2    1E 14           DZERR:	LD	E,DZ		; ?/0 Error
13F4    01              	DB	01H		; Skip "LD E,NF"
13F5    1E 00           NFERR:	LD	E,NF		; ?NF Error
13F7    01              	DB	01H		; Skip "LD E,RD"
13F8    1E 12           DDERR:	LD	E,RD		; ?DD Error
13FA    01              	DB	01H		; Skip "LD E,UF"
13FB    1E 22           UFERR:	LD	E,UF		; ?UF Error
13FD    01              	DB	01H		; Skip "LD E,OV
13FE    1E 0A           OVERR:	LD	E,OV		; ?OV Error
1400    01              	DB	01H		; Skip "LD E,TM"
1401    1E 18           TMERR:	LD	E,TM		; ?TM Error
1403                    ;
1403    CD 21 15        ERROR_:	CALL	CLREG		; Clear registers and stack
1406    32 8A C0        	LD	(CTLOFG),A	; Enable output (A is 0)
1409    CD E2 1A        	CALL	STTLIN		; Start new line
140C    21 F6 12        	LD	HL,ERRORS	; Point to error codes
140F    57              	LD	D,A		; D = 0 (A is 0)
1410    3E 3F           	LD	A,'?'
1412    CD C8 16        	CALL	OUTC		; Output '?'
1415    19              	ADD	HL,DE		; Offset to correct error code
1416    7E              	LD	A,(HL)		; First character
1417    CD C8 16        	CALL	OUTC		; Output it
141A    CD 47 18        	CALL	GETCHR		; Get next character
141D    CD C8 16        	CALL	OUTC		; Output it
1420    21 80 13        	LD	HL,ERRMSG	; "Error" message
1423    CD 8D 21        ERRIN:	CALL	PRS		; Output message
1426    2A A1 C0        	LD	HL,(LINEAT)	; Get line of error
1429    11 FE FF        	LD	DE,-2		; Cold start error if -2
142C    CD B7 16        	CALL	CPDEHL		; See if cold start error
142F    CA 48 10        	JP	Z,CSTART	; Cold start error - Restart
1432    7C              	LD	A,H		; Was it a direct error?
1433    A5              	AND	L		; Line = -1 if direct error
1434    3C              	INC	A
1435    C4 28 28        	CALL	NZ,LINEIN	; No - output line of error
1438    3E              	DB	3EH		; Skip "POP BC"
1439    C1              POPNOK: POP	BC		; Drop address in input buffer
143A                    ;
143A    AF              PRNTOK: XOR	A		; Output "Ok" and get command
143B    32 8A C0        	LD	(CTLOFG),A	; Enable output
143E    CD E2 1A        	CALL	STTLIN		; Start new line
1441    21 8C 13        	LD	HL,OKMSG	; "Ok" message
1444    CD 8D 21        	CALL	PRS		; Output "Ok"
1447    21 FF FF        GETCMD: LD	HL,-1		; Flag direct mode
144A    22 A1 C0        	LD	(LINEAT),HL	; Save as current line
144D    CD 34 16        	CALL	GETLIN		; Get an input line
1450    DA 47 14        	JP	C,GETCMD	; Get line again if break
1453    CD 47 18        	CALL	GETCHR		; Get first character
1456    3C              	INC	A		; Test if end of line
1457    3D              	DEC	A		; Without affecting Carry
1458    CA 47 14        	JP	Z,GETCMD	; Nothing entered - Get another
145B    F5              	PUSH	AF		; Save Carry status
145C    CD 13 19        	CALL	ATOH		; Get line number into DE
145F    D5              	PUSH	DE		; Save line number
1460    CD 4B 15        	CALL	CRUNCH		; Tokenise rest of line
1463    47              	LD	B,A		; Length of tokenised line
1464    D1              	POP	DE		; Restore line number
1465    F1              	POP	AF		; Restore Carry
1466    D2 27 18        	JP	NC,EXCUTE	; No line number - Direct mode
1469    D5              	PUSH	DE		; Save line number
146A    C5              	PUSH	BC		; Save length of tokenised line
146B    AF              	XOR	A
146C    32 11 C1        	LD	(LSTBIN),A	; Clear last byte input
146F    CD 47 18        	CALL	GETCHR		; Get next character
1472    B7              	OR	A		; Set flags
1473    F5              	PUSH	AF		; And save them
1474    CD DB 14        	CALL	SRCHLN		; Search for line number in DE
1477    DA 80 14        	JP	C,LINFND	; Jump if line found
147A    F1              	POP	AF		; Get status
147B    F5              	PUSH	AF		; And re-save
147C    CA B4 19        	JP	Z,ULERR	; Nothing after number - Error
147F    B7              	OR	A		; Clear Carry
1480    C5              LINFND: PUSH	BC		; Save address of line in prog
1481    D2 97 14        	JP	NC,INEWLN	; Line not found - Insert new
1484    EB              	EX	DE,HL		; Next line address in DE
1485    2A 1B C1        	LD	HL,(PROGND)	; End of program
1488    1A              SFTPRG: LD	A,(DE)		; Shift rest of program down
1489    02              	LD	(BC),A
148A    03              	INC	BC		; Next destination
148B    13              	INC	DE		; Next source
148C    CD B7 16        	CALL	CPDEHL		; All done?
148F    C2 88 14        	JP	NZ,SFTPRG	; More to do
1492    60              	LD	H,B		; HL - New end of program
1493    69              	LD	L,C
1494    22 1B C1        	LD	(PROGND),HL	; Update end of program
1497                    ;
1497    D1              INEWLN: POP	DE		; Get address of line,
1498    F1              	POP	AF		; Get status
1499    CA BE 14        	JP	Z,SETPTR	; No text - Set up pointers
149C    2A 1B C1        	LD	HL,(PROGND)	; Get end of program
149F    E3              	EX	(SP),HL		; Get length of input line
14A0    C1              	POP	BC		; End of program to BC
14A1    09              	ADD	HL,BC		; Find new end
14A2    E5              	PUSH	HL		; Save new end
14A3    CD BB 13        	CALL	MOVUP		; Make space for line
14A6    E1              	POP	HL		; Restore new end
14A7    22 1B C1        	LD	(PROGND),HL	; Update end of program pointer
14AA    EB              	EX	DE,HL		; Get line to move up in HL
14AB    74              	LD	(HL),H		; Save MSB
14AC    D1              	POP	DE		; Get new line number
14AD    23              	INC	HL		; Skip pointer
14AE    23              	INC	HL
14AF    73              	LD	(HL),E		; Save LSB of line number
14B0    23              	INC	HL
14B1    72              	LD	(HL),D		; Save MSB of line number
14B2    23              	INC	HL		; To first byte in line
14B3    11 A6 C0        	LD	DE,BUFFER	; Copy buffer to program
14B6    1A              MOVBUF: LD	A,(DE)		; Get source
14B7    77              	LD	(HL),A		; Save destinations
14B8    23              	INC	HL		; Next source
14B9    13              	INC	DE		; Next destination
14BA    B7              	OR	A		; Done?
14BB    C2 B6 14        	JP	NZ,MOVBUF	; No - Repeat
14BE    CD 07 15        SETPTR: CALL	RUNFST		; Set line pointers
14C1    23              	INC	HL		; To LSB of pointer
14C2    EB              	EX	DE,HL		; Address to DE
14C3    62              PTRLP:	LD	H,D		; Address to HL
14C4    6B              	LD	L,E
14C5    7E              	LD	A,(HL)		; Get LSB of pointer
14C6    23              	INC	HL		; To MSB of pointer
14C7    B6              	OR	(HL)		; Compare with MSB pointer
14C8    CA 47 14        	JP	Z,GETCMD	; Get command line if end
14CB    23              	INC	HL		; To LSB of line number
14CC    23              	INC	HL		; Skip line number
14CD    23              	INC	HL		; Point to first byte in line
14CE    AF              	XOR	A		; Looking for 00 byte
14CF    BE              FNDEND: CP	(HL)		; Found end of line?
14D0    23              	INC	HL		; Move to next byte
14D1    C2 CF 14        	JP	NZ,FNDEND	; No - Keep looking
14D4    EB              	EX	DE,HL		; Next line address to HL
14D5    73              	LD	(HL),E		; Save LSB of pointer
14D6    23              	INC	HL
14D7    72              	LD	(HL),D		; Save MSB of pointer
14D8    C3 C3 14        	JP	PTRLP		; Do next line
14DB                    ;
14DB    2A A3 C0        SRCHLN: LD	HL,(BASTXT)	; Start of program text
14DE    44              SRCHLP: LD	B,H		; BC = Address to look at
14DF    4D              	LD	C,L
14E0    7E              	LD	A,(HL)		; Get address of next line
14E1    23              	INC	HL
14E2    B6              	OR	(HL)		; End of program found?
14E3    2B              	DEC	HL
14E4    C8              	RET	Z		; Yes - Line not found
14E5    23              	INC	HL
14E6    23              	INC	HL
14E7    7E              	LD	A,(HL)		; Get LSB of line number
14E8    23              	INC	HL
14E9    66              	LD	H,(HL)		; Get MSB of line number
14EA    6F              	LD	L,A
14EB    CD B7 16        	CALL	CPDEHL		; Compare with line in DE
14EE    60              	LD	H,B		; HL = Start of this line
14EF    69              	LD	L,C
14F0    7E              	LD	A,(HL)		; Get LSB of next line address
14F1    23              	INC	HL
14F2    66              	LD	H,(HL)		; Get MSB of next line address
14F3    6F              	LD	L,A		; Next line to HL
14F4    3F              	CCF
14F5    C8              	RET	Z		; Lines found - Exit
14F6    3F              	CCF
14F7    D0              	RET	NC		; Line not found,at line after
14F8    C3 DE 14        	JP	SRCHLP		; Keep looking
14FB                    ;
14FB    C0              NEW:	RET	NZ		; Return if any more on line
14FC    2A A3 C0        CLRPTR: LD	HL,(BASTXT)	; Point to start of program
14FF    AF              	XOR	A		; Set program area to empty
1500    77              	LD	(HL),A		; Save LSB = 00
1501    23              	INC	HL
1502    77              	LD	(HL),A		; Save MSB = 00
1503    23              	INC	HL
1504    22 1B C1        	LD	(PROGND),HL	; Set program end
1507                    ;
1507    2A A3 C0        RUNFST: LD	HL,(BASTXT)	; Clear all variables
150A    2B              	DEC	HL
150B                    ;
150B    22 13 C1        INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
150E    2A F4 C0        	LD	HL,(LSTRAM)	; Get end of RAM
1511    22 08 C1        	LD	(STRBOT),HL	; Clear string space
1514    AF              	XOR	A
1515    CD 57 18        	CALL	RESTOR		; Reset DATA pointers
1518    2A 1B C1        	LD	HL,(PROGND)	; Get end of program
151B    22 1D C1        	LD	(VAREND),HL	; Clear variables
151E    22 1F C1        	LD	(ARREND),HL	; Clear arrays
1521                    ;
1521    C1              CLREG:	POP	BC		; Save return address
1522    2A 9F C0        	LD	HL,(STRSPC)	; Get end of working RAN
1525    F9              	LD	SP,HL		; Set stack
1526    21 F8 C0        	LD	HL,TMSTPL	; Temporary string pool
1529    22 F6 C0        	LD	(TMSTPT),HL	; Reset temporary string ptr
152C    AF              	XOR	A		; A = 00
152D    6F              	LD	L,A		; HL = 0000
152E    67              	LD	H,A
152F    22 19 C1        	LD	(CONTAD),HL	; No CONTinue
1532    32 10 C1        	LD	(FORFLG),A	; Clear FOR flag
1535    22 23 C1        	LD	(FNRGNM),HL	; Clear FN argument
1538    E5              	PUSH	HL		; HL = 0000
1539    C5              	PUSH	BC		; Put back return
153A    2A 13 C1        DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
153D    C9              	RET			; Return to execution driver
153E                    ;
153E    3E 3F           PROMPT: LD	A,'?'		; '?'
1540    CD C8 16        	CALL	OUTC		; Output character
1543    3E 20           	LD	A,' '		; Space
1545    CD C8 16        	CALL	OUTC		; Output character
1548    C3 93 C0        	JP	RINPUT		; Get input line
154B                    ;
154B    AF              CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
154C    32 F3 C0        	LD	(DATFLG),A	; Reset literal flag
154F    0E 05           	LD	C,2+3		; 2 byte number and 3 nulls
1551    11 A6 C0        	LD	DE,BUFFER	; Start of input buffer
1554    7E              CRNCLP: LD	A,(HL)		; Get byte
1555    FE 20           	CP	' '		; Is it a space?
1557    CA D3 15        	JP	Z,MOVDIR	; Yes - Copy direct
155A    47              	LD	B,A		; Save character
155B    FE 22           	CP	'"'		; Is it a quote?
155D    CA F3 15        	JP	Z,CPYLIT	; Yes - Copy literal string
1560    B7              	OR	A		; Is it end of buffer?
1561    CA FA 15        	JP	Z,ENDBUF	; Yes - End buffer
1564    3A F3 C0        	LD	A,(DATFLG)	; Get data type
1567    B7              	OR	A		; Literal?
1568    7E              	LD	A,(HL)		; Get byte to copy
1569    C2 D3 15        	JP	NZ,MOVDIR	; Literal - Copy direct
156C    FE 3F           	CP	'?'		; Is it '?' short for PRINT
156E    3E 9E           	LD	A,ZPRINT	; "PRINT" token
1570    CA D3 15        	JP	Z,MOVDIR	; Yes - replace it
1573    7E              	LD	A,(HL)		; Get byte again
1574    FE 30           	CP	'0'		; Is it less than '0'
1576    DA 7E 15        	JP	C,FNDWRD	; Yes - Look for reserved words
1579    FE 3C           	CP	60		; ";"+1; Is it "0123456789:;" ?
157B    DA D3 15        	JP	C,MOVDIR	; Yes - copy it direct
157E    D5              FNDWRD: PUSH	DE		; Look for reserved words
157F    11 77 11        	LD	DE,WORDS-1	; Point to table
1582    C5              	PUSH	BC		; Save count
1583    01 CF 15        	LD	BC,RETNAD	; Where to return to
1586    C5              	PUSH	BC		; Save return address
1587    06 7F           	LD	B,ZEND-1	; First token value -1
1589    7E              	LD	A,(HL)		; Get byte
158A    FE 61           	CP	'a'		; Less than 'a' ?
158C    DA 97 15        	JP	C,SEARCH	; Yes - search for words
158F    FE 7B           	CP	'z'+1		; Greater than 'z' ?
1591    D2 97 15        	JP	NC,SEARCH	; Yes - search for words
1594    E6 5F           	AND	01011111B	; Force upper case
1596    77              	LD	(HL),A		; Replace byte
1597    4E              SEARCH: LD	C,(HL)		; Search for a word
1598    EB              	EX	DE,HL
1599    23              GETNXT: INC	HL		; Get next reserved word
159A    B6              	OR	(HL)		; Start of word?
159B    F2 99 15        	JP	P,GETNXT	; No - move on
159E    04              	INC	B		; Increment token value
159F    7E              	LD	A, (HL)		; Get byte from table
15A0    E6 7F           	AND	01111111B	; Strip bit 7
15A2    C8              	RET	Z		; Return if end of list
15A3    B9              	CP	C		; Same character as in buffer?
15A4    C2 99 15        	JP	NZ,GETNXT	; No - get next word
15A7    EB              	EX	DE,HL
15A8    E5              	PUSH	HL		; Save start of word
15A9                    ;
15A9    13              NXTBYT: INC	DE		; Look through rest of word
15AA    1A              	LD	A,(DE)		; Get byte from table
15AB    B7              	OR	A		; End of word ?
15AC    FA CB 15        	JP	M,MATCH		; Yes - Match found
15AF    4F              	LD	C,A		; Save it
15B0    78              	LD	A,B		; Get token value
15B1    FE 88           	CP	ZGOTO		; Is it "GOTO" token ?
15B3    C2 BA 15        	JP	NZ,NOSPC	; No - Don't allow spaces
15B6    CD 47 18        	CALL	GETCHR		; Get next character
15B9    2B              	DEC	HL		; Cancel increment from GETCHR
15BA    23              NOSPC:	INC	HL		; Next byte
15BB    7E              	LD	A,(HL)		; Get byte
15BC    FE 61           	CP	'a'		; Less than 'a' ?
15BE    DA C3 15        	JP	C,NOCHNG	; Yes - don't change
15C1    E6 5F           	AND	01011111B	; Make upper case
15C3    B9              NOCHNG: CP	C		; Same as in buffer ?
15C4    CA A9 15        	JP	Z,NXTBYT	; Yes - keep testing
15C7    E1              	POP	HL		; Get back start of word
15C8    C3 97 15        	JP	SEARCH		; Look at next word
15CB                    ;
15CB    48              MATCH:	LD	C,B		; Word found - Save token value
15CC    F1              	POP	AF		; Throw away return
15CD    EB              	EX	DE,HL
15CE    C9              	RET			; Return to "RETNAD"
15CF    EB              RETNAD: EX	DE,HL		; Get address in string
15D0    79              	LD	A,C		; Get token value
15D1    C1              	POP	BC		; Restore buffer length
15D2    D1              	POP	DE		; Get destination address
15D3    23              MOVDIR: INC	HL		; Next source in buffer
15D4    12              	LD	(DE),A		; Put byte in buffer
15D5    13              	INC	DE		; Move up buffer
15D6    0C              	INC	C		; Increment length of buffer
15D7    D6 3A           	SUB	':'		; End of statement?
15D9    CA E1 15        	JP	Z,SETLIT	; Jump if multi-statement line
15DC    FE 49           	CP	ZDATA-3AH	; Is it DATA statement ?
15DE    C2 E4 15        	JP	NZ,TSTREM	; No - see if REM
15E1    32 F3 C0        SETLIT: LD	(DATFLG),A	; Set literal flag
15E4    D6 54           TSTREM: SUB	ZREM-3AH	; Is it REM?
15E6    C2 54 15        	JP	NZ,CRNCLP	; No - Leave flag
15E9    47              	LD	B,A		; Copy rest of buffer
15EA    7E              NXTCHR: LD	A,(HL)		; Get byte
15EB    B7              	OR	A		; End of line ?
15EC    CA FA 15        	JP	Z,ENDBUF	; Yes - Terminate buffer
15EF    B8              	CP	B		; End of statement ?
15F0    CA D3 15        	JP	Z,MOVDIR	; Yes - Get next one
15F3    23              CPYLIT: INC	HL		; Move up source string
15F4    12              	LD	(DE),A		; Save in destination
15F5    0C              	INC	C		; Increment length
15F6    13              	INC	DE		; Move up destination
15F7    C3 EA 15        	JP	NXTCHR		; Repeat
15FA                    ;
15FA    21 A5 C0        ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
15FD    12              	LD	(DE),A		; Mark end of buffer (A = 00)
15FE    13              	INC	DE
15FF    12              	LD	(DE),A		; A = 00
1600    13              	INC	DE
1601    12              	LD	(DE),A		; A = 00
1602    C9              	RET
1603                    ;
1603    3A 89 C0        DODEL:	LD	A,(NULFLG)	; Get null flag status
1606    B7              	OR	A		; Is it zero?
1607    3E 00           	LD	A,0		; Zero A - Leave flags
1609    32 89 C0        	LD	(NULFLG),A	; Zero null flag
160C    C2 17 16        	JP	NZ,ECHDEL	; Set - Echo it
160F    05              	DEC	B		; Decrement length
1610    CA 34 16        	JP	Z,GETLIN	; Get line again if empty
1613    CD C8 16        	CALL	OUTC		; Output null character
1616    3E              	DB	3EH		; Skip "DEC B"
1617    05              ECHDEL: DEC	B		; Count bytes in buffer
1618    2B              	DEC	HL		; Back space buffer
1619    CA 2B 16        	JP	Z,OTKLN		; No buffer - Try again
161C    7E              	LD	A,(HL)		; Get deleted byte
161D    CD C8 16        	CALL	OUTC		; Echo it
1620    C3 3D 16        	JP	MORINP		; Get more input
1623                    ;
1623    05              DELCHR: DEC	B		; Count bytes in buffer
1624    2B              	DEC	HL		; Back space buffer
1625    CD C8 16        	CALL	OUTC		; Output character in A
1628    C2 3D 16        	JP	NZ,MORINP	; Not end - Get more
162B    CD C8 16        OTKLN:	CALL	OUTC		; Output character in A
162E    CD EF 1A        KILIN:	CALL	PRCRLF		; Output CRLF
1631    C3 34 16        	JP	TTYLIN		; Get line again
1634                    ;
1634                    GETLIN:
1634    21 A6 C0        TTYLIN: LD	HL,BUFFER	; Get a line by character
1637    06 01           	LD	B,1		; Set buffer as empty
1639    AF              	XOR	A
163A    32 89 C0        	LD	(NULFLG),A	; Clear null flag
163D    CD F2 16        MORINP: CALL	CLOTST		; Get character and test ^O
1640    4F              	LD	C,A		; Save character in C
1641    FE 7F           	CP	DEL		; Delete character?
1643    CA 03 16        	JP	Z,DODEL	; Yes - Process it
1646    3A 89 C0        	LD	A,(NULFLG)	; Get null flag
1649    B7              	OR	A		; Test null flag status
164A    CA 56 16        	JP	Z,PROCES	; Reset - Process character
164D    3E 00           	LD	A,0		; Set a null
164F    CD C8 16        	CALL	OUTC		; Output null
1652    AF              	XOR	A		; Clear A
1653    32 89 C0        	LD	(NULFLG),A	; Reset null flag
1656    79              PROCES: LD	A,C		; Get character
1657    FE 07           	CP	CTRLG		; Bell?
1659    CA 9A 16        	JP	Z,PUTCTL	; Yes - Save it
165C    FE 03           	CP	CTRLC		; Is it control "C"?
165E    CC EF 1A        	CALL	Z,PRCRLF	; Yes - Output CRLF
1661    37              	SCF			; Flag break
1662    C8              	RET	Z		; Return if control "C"
1663    FE 0D           	CP	CR		; Is it enter?
1665    CA EA 1A        	JP	Z,ENDINP	; Yes - Terminate input
1668    FE 15           	CP	CTRLU		; Is it control "U"?
166A    CA 2E 16        	JP	Z,KILIN		; Yes - Get another line
166D    FE 40           	CP	'@'		; Is it "kill line"?
166F    CA 2B 16        	JP	Z,OTKLN		; Yes - Kill line
1672    FE 5F           	CP	'_'		; Is it delete?
1674    CA 23 16        	JP	Z,DELCHR	; Yes - Delete character
1677    FE 08           	CP	BKSP		; Is it backspace?
1679    CA 23 16        	JP	Z,DELCHR	; Yes - Delete character
167C    FE 12           	CP	CTRLR		; Is it control "R"?
167E    C2 95 16        	JP	NZ,PUTBUF	; No - Put in buffer
1681    C5              	PUSH	BC		; Save buffer length
1682    D5              	PUSH	DE		; Save DE
1683    E5              	PUSH	HL		; Save buffer address
1684    36 00           	LD	(HL),0		; Mark end of buffer
1686    CD 99 2C        	CALL	OUTNCR		; Output and do CRLF
1689    21 A6 C0        	LD	HL,BUFFER	; Point to buffer start
168C    CD 8D 21        	CALL	PRS		; Output buffer
168F    E1              	POP	HL		; Restore buffer address
1690    D1              	POP	DE		; Restore DE
1691    C1              	POP	BC		; Restore buffer length
1692    C3 3D 16        	JP	MORINP		; Get another character
1695                    ;
1695    FE 20           PUTBUF: CP	' '		; Is it a control code?
1697    DA 3D 16        	JP	C,MORINP	; Yes - Ignore
169A    78              PUTCTL: LD	A,B		; Get number of bytes in buffer
169B    FE 49           	CP	72+1		; Test for line overflow
169D    3E 07           	LD	A,CTRLG		; Set a bell
169F    D2 AF 16        	JP	NC,OUTNBS	; Ring bell if buffer full
16A2    79              	LD	A,C		; Get character
16A3    71              	LD	(HL),C		; Save in buffer
16A4    32 11 C1        	LD	(LSTBIN),A	; Save last input byte
16A7    23              	INC	HL		; Move up buffer
16A8    04              	INC	B		; Increment length
16A9    CD C8 16        OUTIT:	CALL	OUTC		; Output the character entered
16AC    C3 3D 16        	JP	MORINP		; Get another character
16AF                    ;
16AF    CD C8 16        OUTNBS: CALL	OUTC		; Output bell and back over it
16B2    3E 08           	LD	A,BKSP		; Set back space
16B4    C3 A9 16        	JP	OUTIT		; Output it and get more
16B7                    ;
16B7    7C              CPDEHL: LD	A,H		; Get H
16B8    92              	SUB	D		; Compare with D
16B9    C0              	RET	NZ		; Different - Exit
16BA    7D              	LD	A,L		; Get L
16BB    93              	SUB	E		; Compare with E
16BC    C9              	RET			; Return status
16BD                    ;
16BD    7E              CHKSYN: LD	A,(HL)		; Check syntax of character
16BE    E3              	EX	(SP),HL		; Address of test byte
16BF    BE              	CP	(HL)		; Same as in code string?
16C0    23              	INC	HL		; Return address
16C1    E3              	EX	(SP),HL		; Put it back
16C2    CA 47 18        	JP	Z,GETCHR	; Yes - Get next character
16C5    C3 EF 13        	JP	SNERR		; Different - ?SN Error
16C8                    ;
16C8    F5              OUTC:	PUSH	AF		; Save character
16C9    3A 8A C0        	LD	A,(CTLOFG)	; Get control "O" flag
16CC    B7              	OR	A		; Is it set?
16CD    C2 C2 21        	JP	NZ,POPAF	; Yes - don't output
16D0    F1              	POP	AF		; Restore character
16D1    C5              	PUSH	BC		; Save buffer length
16D2    F5              	PUSH	AF		; Save character
16D3    FE 20           	CP	' '		; Is it a control code?
16D5    DA EC 16        	JP	C,DINPOS	; Yes - Don't INC POS(X)
16D8    3A 87 C0        	LD	A,(LWIDTH)	; Get line width
16DB    47              	LD	B,A		; To B
16DC    3A F0 C0        	LD	A,(CURPOS)	; Get cursor position
16DF    04              	INC	B		; Width 255?
16E0    CA E8 16        	JP	Z,INCLEN	; Yes - No width limit
16E3    05              	DEC	B		; Restore width
16E4    B8              	CP	B		; At end of line?
16E5    CC EF 1A        	CALL	Z,PRCRLF	; Yes - output CRLF
16E8    3C              INCLEN: INC	A		; Move on one character
16E9    32 F0 C0        	LD	(CURPOS),A	; Save new position
16EC    F1              DINPOS: POP	AF		; Restore character
16ED    C1              	POP	BC		; Restore buffer length
16EE    CD 84 2C        	CALL	MONOUT		; Send it
16F1    C9              	RET
16F2                    ;
16F2    CD 4C 2B        CLOTST: CALL	GETINP		; Get input character
16F5    E6 7F           	AND	01111111B	; Strip bit 7
16F7    FE 0F           	CP	CTRLO		; Is it control "O"?
16F9    C0              	RET	NZ		; No don't flip flag
16FA    3A 8A C0        	LD	A,(CTLOFG)	; Get flag
16FD    2F              	CPL			; Flip it
16FE    32 8A C0        	LD	(CTLOFG),A	; Put it back
1701    AF              	XOR	A		; Null character
1702    C9              	RET
1703                    ;
1703    CD 13 19        LIST:	CALL	ATOH		; ASCII number to DE
1706    C0              	RET	NZ		; Return if anything extra
1707    C1              	POP	BC		; Rubbish - Not needed
1708    CD DB 14        	CALL	SRCHLN		; Search for line number in DE
170B    C5              	PUSH	BC		; Save address of line
170C    CD 59 17        	CALL	SETLIN		; Set up lines counter
170F    E1              LISTLP: POP	HL		; Restore address of line
1710    4E              	LD	C,(HL)		; Get LSB of next line
1711    23              	INC	HL
1712    46              	LD	B,(HL)		; Get MSB of next line
1713    23              	INC	HL
1714    78              	LD	A,B		; BC = 0 (End of program)?
1715    B1              	OR	C
1716    CA 3A 14        	JP	Z,PRNTOK	; Yes - Go to command mode
1719    CD 62 17        	CALL	COUNT		; Count lines
171C    CD 72 18        	CALL	TSTBRK		; Test for break key
171F    C5              	PUSH	BC		; Save address of next line
1720    CD EF 1A        	CALL	PRCRLF		; Output CRLF
1723    5E              	LD	E,(HL)		; Get LSB of line number
1724    23              	INC	HL
1725    56              	LD	D,(HL)		; Get MSB of line number
1726    23              	INC	HL
1727    E5              	PUSH	HL		; Save address of line start
1728    EB              	EX	DE,HL		; Line number to HL
1729    CD 30 28        	CALL	PRNTHL		; Output line number in decimal
172C    3E 20           	LD	A,' '		; Space after line number
172E    E1              	POP	HL		; Restore start of line address
172F    CD C8 16        LSTLP2: CALL	OUTC		; Output character in A
1732    7E              LSTLP3: LD	A,(HL)		; Get next byte in line
1733    B7              	OR	A		; End of line?
1734    23              	INC	HL		; To next byte in line
1735    CA 0F 17        	JP	Z,LISTLP	; Yes - get next line
1738    F2 2F 17        	JP	P,LSTLP2	; No token - output it
173B    D6 7F           	SUB	ZEND-1		; Find and output word
173D    4F              	LD	C,A		; Token offset+1 to C
173E    11 78 11        	LD	DE,WORDS	; Reserved word list
1741    1A              FNDTOK: LD	A,(DE)		; Get character in list
1742    13              	INC	DE		; Move on to next
1743    B7              	OR	A		; Is it start of word?
1744    F2 41 17        	JP	P,FNDTOK	; No - Keep looking for word
1747    0D              	DEC	C		; Count words
1748    C2 41 17        	JP	NZ,FNDTOK	; Not there - keep looking
174B    E6 7F           OUTWRD: AND	01111111B	; Strip bit 7
174D    CD C8 16        	CALL	OUTC		; Output first character
1750    1A              	LD	A,(DE)		; Get next character
1751    13              	INC	DE		; Move on to next
1752    B7              	OR	A		; Is it end of word?
1753    F2 4B 17        	JP	P,OUTWRD	; No - output the rest
1756    C3 32 17        	JP	LSTLP3		; Next byte in line
1759                    ;
1759    E5              SETLIN: PUSH	HL		; Set up LINES counter
175A    2A 8D C0        	LD	HL,(LINESN)	; Get LINES number
175D    22 8B C0        	LD	(LINESC),HL	; Save in LINES counter
1760    E1              	POP	HL
1761    C9              	RET
1762                    ;
1762    E5              COUNT:	PUSH	HL		; Save code string address
1763    D5              	PUSH	DE
1764    2A 8B C0        	LD	HL,(LINESC)	; Get LINES counter
1767    11 FF FF        	LD	DE,-1
176A    ED 5A           	ADC	HL,DE		; Decrement
176C    22 8B C0        	LD	(LINESC),HL	; Put it back
176F    D1              	POP	DE
1770    E1              	POP	HL		; Restore code string address
1771    F0              	RET	P		; Return if more lines to go
1772    E5              	PUSH	HL		; Save code string address
1773    2A 8D C0        	LD	HL,(LINESN)	; Get LINES number
1776    22 8B C0        	LD	(LINESC),HL	; Reset LINES counter
1779    CD 4C 2B        	CALL	GETINP		; Get input character
177C    FE 03           	CP	CTRLC		; Is it control "C"?
177E    CA 85 17        	JP	Z,RSLNBK	; Yes - Reset LINES and break
1781    E1              	POP	HL		; Restore code string address
1782    C3 62 17        	JP	COUNT		; Keep on counting
1785                    ;
1785    2A 8D C0        RSLNBK: LD	HL,(LINESN)	; Get LINES number
1788    22 8B C0        	LD	(LINESC),HL	; Reset LINES counter
178B    C3 B9 10        	JP	BRKRET		; Go and output "Break"
178E                    ;
178E    3E 64           FOR:	LD	A,64H		; Flag "FOR" assignment
1790    32 10 C1        	LD	(FORFLG),A	; Save "FOR" flag
1793    CD F5 19        	CALL	LET		; Set up initial index
1796    C1              	POP	BC		; Drop RETurn address
1797    E5              	PUSH	HL		; Save code string address
1798    CD DE 19        	CALL	DATA		; Get next statement address
179B    22 0C C1        	LD	(LOOPST),HL	; Save it for start of loop
179E    21 02 00        	LD	HL,2		; Offset for "FOR" block
17A1    39              	ADD	HL,SP		; Point to it
17A2    CD 9C 13        FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
17A5    D1              	POP	DE		; Get code string address
17A6    C2 BE 17        	JP	NZ,FORFND	; No nesting found
17A9    09              	ADD	HL,BC		; Move into "FOR" block
17AA    D5              	PUSH	DE		; Save code string address
17AB    2B              	DEC	HL
17AC    56              	LD	D,(HL)		; Get MSB of loop statement
17AD    2B              	DEC	HL
17AE    5E              	LD	E,(HL)		; Get LSB of loop statement
17AF    23              	INC	HL
17B0    23              	INC	HL
17B1    E5              	PUSH	HL		; Save block address
17B2    2A 0C C1        	LD	HL,(LOOPST)	; Get address of loop statement
17B5    CD B7 16        	CALL	CPDEHL		; Compare the FOR loops
17B8    E1              	POP	HL		; Restore block address
17B9    C2 A2 17        	JP	NZ,FORSLP	; Different FORs - Find another
17BC    D1              	POP	DE		; Restore code string address
17BD    F9              	LD	SP,HL		; Remove all nested loops
17BE                    ;
17BE    EB              FORFND: EX	DE,HL		; Code string address to HL
17BF    0E 08           	LD	C,8
17C1    CD CC 13        	CALL	CHKSTK		; Check for 8 levels of stack
17C4    E5              	PUSH	HL		; Save code string address
17C5    2A 0C C1        	LD	HL,(LOOPST)	; Get first statement of loop
17C8    E3              	EX	(SP),HL		; Save and restore code string
17C9    E5              	PUSH	HL		; Re-save code string address
17CA    2A A1 C0        	LD	HL,(LINEAT)	; Get current line number
17CD    E3              	EX	(SP),HL		; Save and restore code string
17CE    CD B7 1C        	CALL	TSTNUM		; Make sure it's a number
17D1    CD BD 16        	CALL	CHKSYN		; Make sure "TO" is next
17D4    A6              	DB	ZTO		; "TO" token
17D5    CD B4 1C        	CALL	GETNUM		; Get "TO" expression value
17D8    E5              	PUSH	HL		; Save code string address
17D9    CD E2 26        	CALL	BCDEFP		; Move "TO" value to BCDE
17DC    E1              	POP	HL		; Restore code string address
17DD    C5              	PUSH	BC		; Save "TO" value in block
17DE    D5              	PUSH	DE
17DF    01 00 81        	LD	BC,8100H	; BCDE - 1 (default STEP)
17E2    51              	LD	D,C		; C=0
17E3    5A              	LD	E,D		; D=0
17E4    7E              	LD	A,(HL)		; Get next byte in code string
17E5    FE AB           	CP	ZSTEP		; See if "STEP" is stated
17E7    3E 01           	LD	A,1		; Sign of step = 1
17E9    C2 FA 17        	JP	NZ,SAVSTP	; No STEP given - Default to 1
17EC    CD 47 18        	CALL	GETCHR		; Jump over "STEP" token
17EF    CD B4 1C        	CALL	GETNUM		; Get step value
17F2    E5              	PUSH	HL		; Save code string address
17F3    CD E2 26        	CALL	BCDEFP		; Move STEP to BCDE
17F6    CD 96 26        	CALL	TSTSGN		; Test sign of FPREG
17F9    E1              	POP	HL		; Restore code string address
17FA    C5              SAVSTP: PUSH	BC		; Save the STEP value in block
17FB    D5              	PUSH	DE
17FC    F5              	PUSH	AF		; Save sign of STEP
17FD    33              	INC	SP		; Don't save flags
17FE    E5              	PUSH	HL		; Save code string address
17FF    2A 13 C1        	LD	HL,(BRKLIN)	; Get address of index variable
1802    E3              	EX	(SP),HL		; Save and restore code string
1803    06 81           PUTFID: LD	B,ZFOR		; "FOR" block marker
1805    C5              	PUSH	BC		; Save it
1806    33              	INC	SP		; Don't save C
1807                    ;
1807    CD 72 18        RUNCNT: CALL	TSTBRK		; Execution driver - Test break
180A    22 13 C1        	LD	(BRKLIN),HL	; Save code address for break
180D    7E              	LD	A,(HL)		; Get next byte in code string
180E    FE 3A           	CP	':'		; Multi statement line?
1810    CA 27 18        	JP	Z,EXCUTE	; Yes - Execute it
1813    B7              	OR	A		; End of line?
1814    C2 EF 13        	JP	NZ,SNERR	; No - Syntax error
1817    23              	INC	HL		; Point to address of next line
1818    7E              	LD	A,(HL)		; Get LSB of line pointer
1819    23              	INC	HL
181A    B6              	OR	(HL)		; Is it zero (End of prog)?
181B    CA 99 18        	JP	Z,ENDPRG	; Yes - Terminate execution
181E    23              	INC	HL		; Point to line number
181F    5E              	LD	E,(HL)		; Get LSB of line number
1820    23              	INC	HL
1821    56              	LD	D,(HL)		; Get MSB of line number
1822    EB              	EX	DE,HL		; Line number to HL
1823    22 A1 C0        	LD	(LINEAT),HL	; Save as current line number
1826    EB              	EX	DE,HL		; Line number back to DE
1827    CD 47 18        EXCUTE: CALL	GETCHR		; Get key word
182A    11 07 18        	LD	DE,RUNCNT	; Where to RETurn to
182D    D5              	PUSH	DE		; Save for RETurn
182E    C8              IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
182F    D6 80           ONJMP:	SUB	ZEND		; Is it a token?
1831    DA F5 19        	JP	C,LET		; No - try to assign it
1834    FE 25           	CP	ZNEW+1-ZEND	; END to NEW ?
1836    D2 EF 13        	JP	NC,SNERR	; Not a key word - ?SN Error
1839    07              	RLCA			; Double it
183A    4F              	LD	C,A		; BC = Offset into table
183B    06 00           	LD	B,0
183D    EB              	EX	DE,HL		; Save code string address
183E    21 97 12        	LD	HL,WORDTB	; Keyword address table
1841    09              	ADD	HL,BC		; Point to routine address
1842    4E              	LD	C,(HL)		; Get LSB of routine address
1843    23              	INC	HL
1844    46              	LD	B,(HL)		; Get MSB of routine address
1845    C5              	PUSH	BC		; Save routine address
1846    EB              	EX	DE,HL		; Restore code string address
1847                    ;
1847    23              GETCHR: INC	HL		; Point to next character
1848    7E              	LD	A,(HL)		; Get next code string byte
1849    FE 3A           	CP	':'		; Z if ':'
184B    D0              	RET	NC		; NC if > "9"
184C    FE 20           	CP	' '
184E    CA 47 18        	JP	Z,GETCHR	; Skip over spaces
1851    FE 30           	CP	'0'
1853    3F              	CCF			; NC if < '0'
1854    3C              	INC	A		; Test for zero - Leave carry
1855    3D              	DEC	A		; Z if Null
1856    C9              	RET
1857                    ;
1857    EB              RESTOR: EX	DE,HL		; Save code string address
1858    2A A3 C0        	LD	HL,(BASTXT)	; Point to start of program
185B    CA 6C 18        	JP	Z,RESTNL	; Just RESTORE - reset pointer
185E    EB              	EX	DE,HL		; Restore code string address
185F    CD 13 19        	CALL	ATOH		; Get line number to DE
1862    E5              	PUSH	HL		; Save code string address
1863    CD DB 14        	CALL	SRCHLN		; Search for line number in DE
1866    60              	LD	H,B		; HL = Address of line
1867    69              	LD	L,C
1868    D1              	POP	DE		; Restore code string address
1869    D2 B4 19        	JP	NC,ULERR	; ?UL Error if not found
186C    2B              RESTNL: DEC	HL		; Byte before DATA statement
186D    22 21 C1        UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
1870    EB              	EX	DE,HL		; Restore code string address
1871    C9              	RET
1872                    ;
1872
1872    DF              TSTBRK: RST	18H		; Check input status
1873    C8              	RET	Z		; No key, go back
1874    D7              	RST	10H		; Get the key into A
1875    FE 1B           	CP	ESC		; Escape key?
1877    28 11           	JR	Z,BRK		; Yes, break
1879    FE 03           	CP	CTRLC		; <Ctrl-C>
187B    28 0D           	JR	Z,BRK		; Yes, break
187D    FE 13           	CP	CTRLS		; Stop scrolling?
187F    C0              	RET	NZ		; Other key, ignore
1880                    ;
1880
1880    D7              STALL:	RST	10H		; Wait for key
1881    FE 11           	CP	CTRLQ		; Resume scrolling?
1883    C8              	RET	Z		; Release the chokehold
1884    FE 03           	CP	CTRLC		; Second break?
1886    28 07           	JR	Z,STOP		; Break during hold exits prog
1888    18 F6           	JR	STALL		; Loop until <Ctrl-Q> or <brk>
188A                    ;
188A    3E FF           BRK:	LD	A,0FFH		; Set BRKFLG
188C    32 92 C0        	LD	(BRKFLG),A	; Store it
188F                    ;
188F
188F    C0              STOP:	RET	NZ		; Exit if anything else
1890    F6              	DB	0F6H		; Flag "STOP"
1891    C0              PEND:	RET	NZ		; Exit if anything else
1892    22 13 C1        	LD	(BRKLIN),HL	; Save point of break
1895    21              	DB	21H		; Skip "OR 11111111B"
1896    F6 FF           INPBRK: OR	11111111B	; Flag "Break" wanted
1898    C1              	POP	BC		; Return not needed and more
1899    2A A1 C0        ENDPRG: LD	HL,(LINEAT)	; Get current line number
189C    F5              	PUSH	AF		; Save STOP / END status
189D    7D              	LD	A,L		; Is it direct break?
189E    A4              	AND	H
189F    3C              	INC	A		; Line is -1 if direct break
18A0    CA AC 18        	JP	Z,NOLIN		; Yes - No line number
18A3    22 17 C1        	LD	(ERRLIN),HL	; Save line of break
18A6    2A 13 C1        	LD	HL,(BRKLIN)	; Get point of break
18A9    22 19 C1        	LD	(CONTAD),HL	; Save point to CONTinue
18AC    AF              NOLIN:	XOR	A
18AD    32 8A C0        	LD	(CTLOFG),A	; Enable output
18B0    CD E2 1A        	CALL	STTLIN		; Start a new line
18B3    F1              	POP	AF		; Restore STOP / END status
18B4    21 92 13        	LD	HL,BRKMSG	; "Break" message
18B7    C2 23 14        	JP	NZ,ERRIN	; "in line" wanted?
18BA    C3 3A 14        	JP	PRNTOK		; Go to command mode
18BD                    ;
18BD    2A 19 C1        CONT:	LD	HL,(CONTAD)	; Get CONTinue address
18C0    7C              	LD	A,H		; Is it zero?
18C1    B5              	OR	L
18C2    1E 20           	LD	E,CN		; ?CN Error
18C4    CA 03 14        	JP	Z,ERROR_	; Yes - output "?CN Error"
18C7    EB              	EX	DE,HL		; Save code string address
18C8    2A 17 C1        	LD	HL,(ERRLIN)	; Get line of last break
18CB    22 A1 C0        	LD	(LINEAT),HL	; Set up current line number
18CE    EB              	EX	DE,HL		; Restore code string address
18CF    C9              	RET			; CONTinue where left off
18D0                    ;
18D0    CD 15 24        NULL:	CALL	GETINT		; Get integer 0-255
18D3    C0              	RET	NZ		; Return if bad value
18D4    32 86 C0        	LD	(NULLS),A	; Set nulls number
18D7    C9              	RET
18D8                    ;
18D8
18D8    E5              ACCSUM: PUSH	HL		; Save address in array
18D9    2A 8F C0        	LD	HL,(CHKSUM)	; Get check sum
18DC    06 00           	LD	B,0		; BC - Value of byte
18DE    4F              	LD	C,A
18DF    09              	ADD	HL,BC		; Add byte to check sum
18E0    22 8F C0        	LD	(CHKSUM),HL	; Re-save check sum
18E3    E1              	POP	HL		; Restore address in array
18E4    C9              	RET
18E5                    ;
18E5    7E              CHKLTR: LD	A,(HL)		; Get byte
18E6    FE 41           	CP	'A'		; < 'a' ?
18E8    D8              	RET	C		; Carry set if not letter
18E9    FE 5B           	CP	'Z'+1		; > 'z' ?
18EB    3F              	CCF
18EC    C9              	RET			; Carry set if not letter
18ED                    ;
18ED    CD 47 18        FPSINT: CALL	GETCHR		; Get next character
18F0    CD B4 1C        POSINT: CALL	GETNUM		; Get integer 0 to 32767
18F3    CD 96 26        DEPINT: CALL	TSTSGN		; Test sign of FPREG
18F6    FA 0E 19        	JP	M,FCERR		; Negative - ?FC Error
18F9    3A 2C C1        DEINT:	LD	A,(FPEXP)	; Get integer value to DE
18FC    FE 90           	CP	80H+16		; Exponent in range (16 bits)?
18FE    DA 3E 27        	JP	C,FPINT		; Yes - convert it
1901    01 80 90        	LD	BC,9080H	; BCDE = -32768
1904    11 00 00        	LD	DE,0000
1907    E5              	PUSH	HL		; Save code string address
1908    CD 11 27        	CALL	CMPNUM		; Compare FPREG with BCDE
190B    E1              	POP	HL		; Restore code string address
190C    51              	LD	D,C		; MSB to D
190D    C8              	RET	Z		; Return if in range
190E    1E 08           FCERR:	LD	E,FC		; ?FC Error
1910    C3 03 14        	JP	ERROR_		; Output error-
1913                    ;
1913    2B              ATOH:	DEC	HL		; ASCII number to DE binary
1914    11 00 00        GETLN:	LD	DE,0		; Get number to DE
1917    CD 47 18        GTLNLP: CALL	GETCHR		; Get next character
191A    D0              	RET	NC		; Exit if not a digit
191B    E5              	PUSH	HL		; Save code string address
191C    F5              	PUSH	AF		; Save digit
191D    21 98 19        	LD	HL,65529/10	; Largest number 65529
1920    CD B7 16        	CALL	CPDEHL		; Number in range?
1923    DA EF 13        	JP	C,SNERR		; No - ?SN Error
1926    62              	LD	H,D		; HL = Number
1927    6B              	LD	L,E
1928    19              	ADD	HL,DE		; Times 2
1929    29              	ADD	HL,HL		; Times 4
192A    19              	ADD	HL,DE		; Times 5
192B    29              	ADD	HL,HL		; Times 10
192C    F1              	POP	AF		; Restore digit
192D    D6 30           	SUB	'0'		; Make it 0 to 9
192F    5F              	LD	E,A		; DE = Value of digit
1930    16 00           	LD	D,0
1932    19              	ADD	HL,DE		; Add to number
1933    EB              	EX	DE,HL		; Number to DE
1934    E1              	POP	HL		; Restore code string address
1935    C3 17 19        	JP	GTLNLP		; Go to next character
1938                    ;
1938    CA 0B 15        CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
193B    CD F0 18        	CALL	POSINT		; Get integer 0 to 32767 to DE
193E    2B              	DEC	HL		; Cancel increment
193F    CD 47 18        	CALL	GETCHR		; Get next character
1942    E5              	PUSH	HL		; Save code string address
1943    2A F4 C0        	LD	HL,(LSTRAM)	; Get end of RAM
1946    CA 5B 19        	JP	Z,STORED	; No value given - Use stored
1949    E1              	POP	HL		; Restore code string address
194A    CD BD 16        	CALL	CHKSYN		; Check for comma
194D    2C              	DB	','
194E    D5              	PUSH	DE		; Save number
194F    CD F0 18        	CALL	POSINT		; Get integer 0 to 32767
1952    2B              	DEC	HL		; Cancel increment
1953    CD 47 18        	CALL	GETCHR		; Get next character
1956    C2 EF 13        	JP	NZ,SNERR	; ?SN Error if more on line
1959    E3              	EX	(SP),HL		; Save code string address
195A    EB              	EX	DE,HL		; Number to DE
195B    7D              STORED: LD	A,L		; Get LSB of new RAM top
195C    93              	SUB	E		; Subtract LSB of string space
195D    5F              	LD	E,A		; Save LSB
195E    7C              	LD	A,H		; Get MSB of new RAM top
195F    9A              	SBC	A,D		; Subtract MSB of string space
1960    57              	LD	D,A		; Save MSB
1961    DA E4 13        	JP	C,OMERR		; ?OM Error if not enough mem
1964    E5              	PUSH	HL		; Save RAM top
1965    2A 1B C1        	LD	HL,(PROGND)	; Get program end
1968    01 28 00        	LD	BC,40		; 40 Bytes minimum working RAM
196B    09              	ADD	HL,BC		; Get lowest address
196C    CD B7 16        	CALL	CPDEHL		; Enough memory?
196F    D2 E4 13        	JP	NC,OMERR	; No - ?OM Error
1972    EB              	EX	DE,HL		; RAM top to HL
1973    22 9F C0        	LD	(STRSPC),HL	; Set new string space
1976    E1              	POP	HL		; End of memory to use
1977    22 F4 C0        	LD	(LSTRAM),HL	; Set new top of RAM
197A    E1              	POP	HL		; Restore code string address
197B    C3 0B 15        	JP	INTVAR		; Initialise variables
197E                    ;
197E    CA 07 15        RUN:	JP	Z,RUNFST	; RUN from start if just RUN
1981    CD 0B 15        	CALL	INTVAR		; Initialise variables
1984    01 07 18        	LD	BC,RUNCNT	; Execution driver loop
1987    C3 9A 19        	JP	RUNLIN		; RUN from line number
198A                    ;
198A    0E 03           GOSUB:	LD	C,3		; 3 Levels of stack needed
198C    CD CC 13        	CALL	CHKSTK		; Check for 3 levels of stack
198F    C1              	POP	BC		; Get return address
1990    E5              	PUSH	HL		; Save code string for RETURN
1991    E5              	PUSH	HL		; And for GOSUB routine
1992    2A A1 C0        	LD	HL,(LINEAT)	; Get current line
1995    E3              	EX	(SP),HL		; Into stack - Code string out
1996    3E 8C           	LD	A,ZGOSUB	; "GOSUB" token
1998    F5              	PUSH	AF		; Save token
1999    33              	INC	SP		; Don't save flags
199A                    ;
199A    C5              RUNLIN: PUSH	BC		; Save return address
199B    CD 13 19        GOTO:	CALL	ATOH		; ASCII number to DE binary
199E    CD E0 19        	CALL	REM		; Get end of line
19A1    E5              	PUSH	HL		; Save end of line
19A2    2A A1 C0        	LD	HL,(LINEAT)	; Get current line
19A5    CD B7 16        	CALL	CPDEHL		; Line after current?
19A8    E1              	POP	HL		; Restore end of line
19A9    23              	INC	HL		; Start of next line
19AA    DC DE 14        	CALL	C,SRCHLP	; Line is after current line
19AD    D4 DB 14        	CALL	NC,SRCHLN	; Line is before current line
19B0    60              	LD	H,B		; Set up code string address
19B1    69              	LD	L,C
19B2    2B              	DEC	HL		; Incremented after
19B3    D8              	RET	C		; Line found
19B4    1E 0E           ULERR:	LD	E,UL		; ?UL Error
19B6    C3 03 14        	JP	ERROR_		; Output error message
19B9                    ;
19B9    C0              RETURN: RET	NZ		; Return if not just RETURN
19BA    16 FF           	LD	D,-1		; Flag "GOSUB" search
19BC    CD 98 13        	CALL	BAKSTK		; Look "GOSUB" block
19BF    F9              	LD	SP,HL		; Kill all FORs in subroutine
19C0    FE 8C           	CP	ZGOSUB		; Test for "GOSUB" token
19C2    1E 04           	LD	E,RG		; ?RG Error
19C4    C2 03 14        	JP	NZ,ERROR_	; Error if no "GOSUB" found
19C7    E1              	POP	HL		; Get RETURN line number
19C8    22 A1 C0        	LD	(LINEAT),HL	; Save as current
19CB    23              	INC	HL		; Was it from direct statement?
19CC    7C              	LD	A,H
19CD    B5              	OR	L		; Return to line
19CE    C2 D8 19        	JP	NZ,RETLIN	; No - Return to line
19D1    3A 11 C1        	LD	A,(LSTBIN)	; Any INPUT in subroutine?
19D4    B7              	OR	A		; If so buffer is corrupted
19D5    C2 39 14        	JP	NZ,POPNOK	; Yes - Go to command mode
19D8    21 07 18        RETLIN: LD	HL,RUNCNT	; Execution driver loop
19DB    E3              	EX	(SP),HL		; Into stack - Code string out
19DC    3E              	DB	3EH		; Skip "POP HL"
19DD    E1              NXTDTA: POP	HL		; Restore code string address
19DE                    ;
19DE    01 3A           DATA:	DB	01H,3AH		; ':' End of statement
19E0    0E 00           REM:	LD	C,0		; 00	End of statement
19E2    06 00           	LD	B,0
19E4    79              NXTSTL: LD	A,C		; Statement and byte
19E5    48              	LD	C,B
19E6    47              	LD	B,A		; Statement end byte
19E7    7E              NXTSTT: LD	A,(HL)		; Get byte
19E8    B7              	OR	A		; End of line?
19E9    C8              	RET	Z		; Yes - Exit
19EA    B8              	CP	B		; End of statement?
19EB    C8              	RET	Z		; Yes - Exit
19EC    23              	INC	HL		; Next byte
19ED    FE 22           	CP	'"'		; Literal string?
19EF    CA E4 19        	JP	Z,NXTSTL	; Yes - Look for another '"'
19F2    C3 E7 19        	JP	NXTSTT		; Keep looking
19F5                    ;
19F5    CD AA 1E        LET:	CALL	GETVAR		; Get variable name
19F8    CD BD 16        	CALL	CHKSYN		; Make sure "=" follows
19FB    B4              	DB	ZEQUAL		; "=" token
19FC    D5              	PUSH	DE		; Save address of variable
19FD    3A F2 C0        	LD	A,(TYPE)	; Get data type
1A00    F5              	PUSH	AF		; Save type
1A01    CD C6 1C        	CALL	EVAL		; Evaluate expression
1A04    F1              	POP	AF		; Restore type
1A05    E3              	EX	(SP),HL		; Save code - Get var addr
1A06    22 13 C1        	LD	(BRKLIN),HL	; Save address of variable
1A09    1F              	RRA			; Adjust type
1A0A    CD B9 1C        	CALL	CHKTYP		; Check types are the same
1A0D    CA 48 1A        	JP	Z,LETNUM	; Numeric - Move value
1A10    E5              LETSTR: PUSH	HL		; Save address of string var
1A11    2A 29 C1        	LD	HL,(FPREG)	; Pointer to string entry
1A14    E5              	PUSH	HL		; Save it on stack
1A15    23              	INC	HL		; Skip over length
1A16    23              	INC	HL
1A17    5E              	LD	E,(HL)		; LSB of string address
1A18    23              	INC	HL
1A19    56              	LD	D,(HL)		; MSB of string address
1A1A    2A A3 C0        	LD	HL,(BASTXT)	; Point to start of program
1A1D    CD B7 16        	CALL	CPDEHL		; Is string before program?
1A20    D2 37 1A        	JP	NC,CRESTR	; Yes - Create string entry
1A23    2A 9F C0        	LD	HL,(STRSPC)	; Point to string space
1A26    CD B7 16        	CALL	CPDEHL		; Is string literal in program?
1A29    D1              	POP	DE		; Restore address of string
1A2A    D2 3F 1A        	JP	NC,MVSTPT	; Yes - Set up pointer
1A2D    21 04 C1        	LD	HL,TMPSTR	; Temporary string pool
1A30    CD B7 16        	CALL	CPDEHL		; Is string in temporary pool?
1A33    D2 3F 1A        	JP	NC,MVSTPT	; No - Set up pointer
1A36    3E              	DB	3EH		; Skip "POP DE"
1A37    D1              CRESTR: POP	DE		; Restore address of string
1A38    CD EE 22        	CALL	BAKTMP		; Back to last tmp-str entry
1A3B    EB              	EX	DE,HL		; Address of string entry
1A3C    CD 27 21        	CALL	SAVSTR		; Save string in string area
1A3F    CD EE 22        MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
1A42    E1              	POP	HL		; Get string pointer
1A43    CD F1 26        	CALL	DETHL4		; Move string pointer to var
1A46    E1              	POP	HL		; Restore code string address
1A47    C9              	RET
1A48                    ;
1A48    E5              LETNUM: PUSH	HL		; Save address of variable
1A49    CD EE 26        	CALL	FPTHL		; Move value to variable
1A4C    D1              	POP	DE		; Restore address of variable
1A4D    E1              	POP	HL		; Restore code string address
1A4E    C9              	RET
1A4F                    ;
1A4F    CD 15 24        ON:	CALL	GETINT		; Get integer 0-255
1A52    7E              	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
1A53    47              	LD	B,A		; Save in B
1A54    FE 8C           	CP	ZGOSUB		; "GOSUB" token?
1A56    CA 5E 1A        	JP	Z,ONGO		; Yes - Find line number
1A59    CD BD 16        	CALL	CHKSYN		; Make sure it's "GOTO"
1A5C    88              	DB	ZGOTO		; "GOTO" token
1A5D    2B              	DEC	HL		; Cancel increment
1A5E    4B              ONGO:	LD	C,E		; Integer of branch value
1A5F    0D              ONGOLP: DEC	C		; Count branches
1A60    78              	LD	A,B		; Get "GOTO" or "GOSUB" token
1A61    CA 2F 18        	JP	Z,ONJMP		; Go to that line if right one
1A64    CD 14 19        	CALL	GETLN		; Get line number to DE
1A67    FE 2C           	CP	','		; Another line number?
1A69    C0              	RET	NZ		; No - Drop through
1A6A    C3 5F 1A        	JP	ONGOLP		; Yes - loop
1A6D                    ;
1A6D    CD C6 1C        IF_:	CALL	EVAL		; Evaluate expression
1A70    7E              	LD	A,(HL)		; Get token
1A71    FE 88           	CP	ZGOTO		; "GOTO" token?
1A73    CA 7B 1A        	JP	Z,IFGO		; Yes - Get line
1A76    CD BD 16        	CALL	CHKSYN		; Make sure it's "THEN"
1A79    A9              	DB	ZTHEN		; "THEN" token
1A7A    2B              	DEC	HL		; Cancel increment
1A7B    CD B7 1C        IFGO:	CALL	TSTNUM		; Make sure it's numeric
1A7E    CD 96 26        	CALL	TSTSGN		; Test state of expression
1A81    CA E0 19        	JP	Z,REM		; False - Drop through
1A84    CD 47 18        	CALL	GETCHR		; Get next character
1A87    DA 9B 19        	JP	C,GOTO		; Number - GOTO that line
1A8A    C3 2E 18        	JP	IFJMP		; Otherwise do statement
1A8D                    ;
1A8D    2B              MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
1A8E    CD 47 18        	CALL	GETCHR		; Get next character
1A91    CA EF 1A        PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
1A94    C8              PRNTLP: RET	Z		; End of list - Exit
1A95    FE A5           	CP	ZTAB		; "TAB(" token?
1A97    CA 22 1B        	JP	Z,DOTAB		; Yes - Do TAB routine
1A9A    FE A8           	CP	ZSPC		; "SPC(" token?
1A9C    CA 22 1B        	JP	Z,DOTAB		; Yes - Do SPC routine
1A9F    E5              	PUSH	HL		; Save code string address
1AA0    FE 2C           	CP	','		; Comma?
1AA2    CA 0B 1B        	JP	Z,DOCOM		; Yes - Move to next zone
1AA5    FE 3B           	CP	59;";"		; Semi-colon?
1AA7    CA 45 1B        	JP	Z,NEXITM	; Do semi-colon routine
1AAA    C1              	POP	BC		; Code string address to BC
1AAB    CD C6 1C        	CALL	EVAL		; Evaluate expression
1AAE    E5              	PUSH	HL		; Save code string address
1AAF    3A F2 C0        	LD	A,(TYPE)	; Get variable type
1AB2    B7              	OR	A		; Is it a string variable?
1AB3    C2 DB 1A        	JP	NZ,PRNTST	; Yes - Output string contents
1AB6    CD 3B 28        	CALL	NUMASC		; Convert number to text
1AB9    CD 4B 21        	CALL	CRTST		; Create temporary string
1ABC    36 20           	LD	(HL),' '	; Followed by a space
1ABE    2A 29 C1        	LD	HL,(FPREG)	; Get length of output
1AC1    34              	INC	(HL)		; Plus 1 for the space
1AC2    2A 29 C1        	LD	HL,(FPREG)	; < Not needed >
1AC5    3A 87 C0        	LD	A,(LWIDTH)	; Get width of line
1AC8    47              	LD	B,A		; To B
1AC9    04              	INC	B		; Width 255 (No limit)?
1ACA    CA D7 1A        	JP	Z,PRNTNB	; Yes - Output number string
1ACD    04              	INC	B		; Adjust it
1ACE    3A F0 C0        	LD	A,(CURPOS)	; Get cursor position
1AD1    86              	ADD	A,(HL)		; Add length of string
1AD2    3D              	DEC	A		; Adjust it
1AD3    B8              	CP	B		; Will output fit on this line?
1AD4    D4 EF 1A        	CALL	NC,PRCRLF	; No - CRLF first
1AD7    CD 90 21        PRNTNB: CALL	PRS1		; Output string at (HL)
1ADA    AF              	XOR	A		; Skip CALL by setting 'z' flag
1ADB    C4 90 21        PRNTST: CALL	NZ,PRS1		; Output string at (HL)
1ADE    E1              	POP	HL		; Restore code string address
1ADF    C3 8D 1A        	JP	MRPRNT		; See if more to PRINT
1AE2                    ;
1AE2    3A F0 C0        STTLIN: LD	A,(CURPOS)	; Make sure on new line
1AE5    B7              	OR	A		; Already at start?
1AE6    C8              	RET	Z		; Yes - Do nothing
1AE7    C3 EF 1A        	JP	PRCRLF		; Start a new line
1AEA                    ;
1AEA    36 00           ENDINP: LD	(HL),0		; Mark end of buffer
1AEC    21 A5 C0        	LD	HL,BUFFER-1	; Point to buffer
1AEF    3E 0D           PRCRLF: LD	A,CR		; Load a CR
1AF1    CD C8 16        	CALL	OUTC		; Output character
1AF4    3E 0A           	LD	A,LF		; Load a LF
1AF6    CD C8 16        	CALL	OUTC		; Output character
1AF9    AF              DONULL: XOR	A		; Set to position 0
1AFA    32 F0 C0        	LD	(CURPOS),A	; Store it
1AFD    3A 86 C0        	LD	A,(NULLS)	; Get number of nulls
1B00    3D              NULLP:	DEC	A		; Count them
1B01    C8              	RET	Z		; Return if done
1B02    F5              	PUSH	AF		; Save count
1B03    AF              	XOR	A		; Load a null
1B04    CD C8 16        	CALL	OUTC		; Output it
1B07    F1              	POP	AF		; Restore count
1B08    C3 00 1B        	JP	NULLP		; Keep counting
1B0B                    ;
1B0B    3A 88 C0        DOCOM:	LD	A,(COMMAN)	; Get comma width
1B0E    47              	LD	B,A		; Save in B
1B0F    3A F0 C0        	LD	A,(CURPOS)	; Get current position
1B12    B8              	CP	B		; Within the limit?
1B13    D4 EF 1A        	CALL	NC,PRCRLF	; No - output CRLF
1B16    D2 45 1B        	JP	NC,NEXITM	; Get next item
1B19    D6 0E           ZONELP: SUB	14		; Next zone of 14 characters
1B1B    D2 19 1B        	JP	NC,ZONELP	; Repeat if more zones
1B1E    2F              	CPL			; Number of spaces to output
1B1F    C3 3A 1B        	JP	ASPCS		; Output them
1B22                    ;
1B22    F5              DOTAB:	PUSH	AF		; Save token
1B23    CD 12 24        	CALL	FNDNUM		; Evaluate expression
1B26    CD BD 16        	CALL	CHKSYN		; Make sure ")" follows
1B29    29              	DB	")"
1B2A    2B              	DEC	HL		; Back space on to ")"
1B2B    F1              	POP	AF		; Restore token
1B2C    D6 A8           	SUB	ZSPC		; Was it "SPC(" ?
1B2E    E5              	PUSH	HL		; Save code string address
1B2F    CA 35 1B        	JP	Z,DOSPC	; Yes - Do 'E' spaces
1B32    3A F0 C0        	LD	A,(CURPOS)	; Get current position
1B35    2F              DOSPC:	CPL			; Number of spaces to print to
1B36    83              	ADD	A,E		; Total number to print
1B37    D2 45 1B        	JP	NC,NEXITM	; TAB < Current POS(X)
1B3A    3C              ASPCS:	INC	A		; Output A spaces
1B3B    47              	LD	B,A		; Save number to print
1B3C    3E 20           	LD	A,' '		; Space
1B3E    CD C8 16        SPCLP:	CALL	OUTC		; Output character in A
1B41    05              	DEC	B		; Count them
1B42    C2 3E 1B        	JP	NZ,SPCLP	; Repeat if more
1B45    E1              NEXITM: POP	HL		; Restore code string address
1B46    CD 47 18        	CALL	GETCHR		; Get next character
1B49    C3 94 1A        	JP	PRNTLP		; More to print
1B4C                    ;
1B4C    3F 52 65 64     REDO:	DB	"?Redo from start",CR,LF,0
1B50    6F 20 66 72
1B54    6F 6D 20 73
1B58    74 61 72 74
1B5C    0D 0A 00
1B5F                    ;
1B5F    3A 12 C1        BADINP: LD	A,(READFG)	; READ or INPUT?
1B62    B7              	OR	A
1B63    C2 E9 13        	JP	NZ,DATSNR	; READ - ?SN Error
1B66    C1              	POP	BC		; Throw away code string addr
1B67    21 4C 1B        	LD	HL,REDO		; "Redo from start" message
1B6A    CD 8D 21        	CALL	PRS		; Output string
1B6D    C3 3A 15        	JP	DOAGN		; Do last INPUT again
1B70                    ;
1B70    CD F8 20        INPUT:	CALL	IDTEST		; Test for illegal direct
1B73    7E              	LD	A,(HL)		; Get character after "INPUT"
1B74    FE 22           	CP	'"'		; Is there a prompt string?
1B76    3E 00           	LD	A,0		; Clear A and leave flags
1B78    32 8A C0        	LD	(CTLOFG),A	; Enable output
1B7B    C2 8A 1B        	JP	NZ,NOPMPT	; No prompt - get input
1B7E    CD 4C 21        	CALL	QTSTR		; Get string terminated by '"'
1B81    CD BD 16        	CALL	CHKSYN		; Check for ';' after prompt
1B84    3B              	DB	';'
1B85    E5              	PUSH	HL		; Save code string address
1B86    CD 90 21        	CALL	PRS1		; Output prompt string
1B89    3E              	DB	3EH		; Skip "PUSH HL"
1B8A    E5              NOPMPT: PUSH	HL		; Save code string address
1B8B    CD 3E 15        	CALL	PROMPT		; Get input with "? " prompt
1B8E    C1              	POP	BC		; Restore code string address
1B8F    DA 96 18        	JP	C,INPBRK	; Break pressed - Exit
1B92    23              	INC	HL		; Next byte
1B93    7E              	LD	A,(HL)		; Get it
1B94    B7              	OR	A		; End of line?
1B95    2B              	DEC	HL		; Back again
1B96    C5              	PUSH	BC		; Re-save code string address
1B97    CA DD 19        	JP	Z,NXTDTA	; Yes - Find next DATA stmt
1B9A    36 2C           	LD	(HL),','	; Store comma as separator
1B9C    C3 A4 1B        	JP	NXTITM		; Get next item
1B9F                    ;
1B9F    E5              READ:	PUSH	HL		; Save code string address
1BA0    2A 21 C1        	LD	HL,(NXTDAT)	; Next DATA statement
1BA3    F6              	DB	0F6H		; Flag "READ"
1BA4    AF              NXTITM: XOR	A		; Flag "INPUT"
1BA5    32 12 C1        	LD	(READFG),A	; Save "READ"/"INPUT" flag
1BA8    E3              	EX	(SP),HL		; Get code str' , Save pointer
1BA9    C3 B0 1B        	JP	GTVLUS		; Get values
1BAC                    ;
1BAC    CD BD 16        NEDMOR: CALL	CHKSYN		; Check for comma between items
1BAF    2C              	DB	','
1BB0    CD AA 1E        GTVLUS: CALL	GETVAR		; Get variable name
1BB3    E3              	EX	(SP),HL		; Save code str" , Get pointer
1BB4    D5              	PUSH	DE		; Save variable address
1BB5    7E              	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
1BB6    FE 2C           	CP	','		; Comma?
1BB8    CA D8 1B        	JP	Z,ANTVLU	; Yes - Get another value
1BBB    3A 12 C1        	LD	A,(READFG)	; Is it READ?
1BBE    B7              	OR	A
1BBF    C2 45 1C        	JP	NZ,FDTLP	; Yes - Find next DATA stmt
1BC2    3E 3F           	LD	A,'?'		; More INPUT needed
1BC4    CD C8 16        	CALL	OUTC		; Output character
1BC7    CD 3E 15        	CALL	PROMPT		; Get INPUT with prompt
1BCA    D1              	POP	DE		; Variable address
1BCB    C1              	POP	BC		; Code string address
1BCC    DA 96 18        	JP	C,INPBRK	; Break pressed
1BCF    23              	INC	HL		; Point to next DATA byte
1BD0    7E              	LD	A,(HL)		; Get byte
1BD1    B7              	OR	A		; Is it zero (No input) ?
1BD2    2B              	DEC	HL		; Back space INPUT pointer
1BD3    C5              	PUSH	BC		; Save code string address
1BD4    CA DD 19        	JP	Z,NXTDTA	; Find end of buffer
1BD7    D5              	PUSH	DE		; Save variable address
1BD8    3A F2 C0        ANTVLU: LD	A,(TYPE)	; Check data type
1BDB    B7              	OR	A		; Is it numeric?
1BDC    CA 02 1C        	JP	Z,INPBIN	; Yes - Convert to binary
1BDF    CD 47 18        	CALL	GETCHR		; Get next character
1BE2    57              	LD	D,A		; Save input character
1BE3    47              	LD	B,A		; Again
1BE4    FE 22           	CP	'"'		; Start of literal sting?
1BE6    CA F6 1B        	JP	Z,STRENT	; Yes - Create string entry
1BE9    3A 12 C1        	LD	A,(READFG)	; "READ" or "INPUT" ?
1BEC    B7              	OR	A
1BED    57              	LD	D,A		; Save 00 if "INPUT"
1BEE    CA F3 1B        	JP	Z,ITMSEP	; "INPUT" - End with 00
1BF1    16 3A           	LD	D,':'		; "DATA" - End with 00 or ':'
1BF3    06 2C           ITMSEP: LD	B,','		; Item separator
1BF5    2B              	DEC	HL		; Back space for DTSTR
1BF6    CD 4F 21        STRENT: CALL	DTSTR		; Get string terminated by D
1BF9    EB              	EX	DE,HL		; String address to DE
1BFA    21 0D 1C        	LD	HL,LTSTND	; Where to go after LETSTR
1BFD    E3              	EX	(SP),HL		; Save HL , get input pointer
1BFE    D5              	PUSH	DE		; Save address of string
1BFF    C3 10 1A        	JP	LETSTR		; Assign string to variable
1C02                    ;
1C02    CD 47 18        INPBIN: CALL	GETCHR		; Get next character
1C05    CD 9D 27        	CALL	ASCTFP		; Convert ASCII to FP number
1C08    E3              	EX	(SP),HL		; Save input ptr, Get var addr
1C09    CD EE 26        	CALL	FPTHL		; Move FPREG to variable
1C0C    E1              	POP	HL		; Restore input pointer
1C0D    2B              LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
1C0E    CD 47 18        	CALL	GETCHR		; Get next character
1C11    CA 19 1C        	JP	Z,MORDT		; End of line - More needed?
1C14    FE 2C           	CP	','		; Another value?
1C16    C2 5F 1B        	JP	NZ,BADINP	; No - Bad input
1C19    E3              MORDT:	EX	(SP),HL		; Get code string address
1C1A    2B              	DEC	HL		; DEC 'cos GETCHR INCs
1C1B    CD 47 18        	CALL	GETCHR		; Get next character
1C1E    C2 AC 1B        	JP	NZ,NEDMOR	; More needed - Get it
1C21    D1              	POP	DE		; Restore DATA pointer
1C22    3A 12 C1        	LD	A,(READFG)	; "READ" or "INPUT" ?
1C25    B7              	OR	A
1C26    EB              	EX	DE,HL		; DATA pointer to HL
1C27    C2 6D 18        	JP	NZ,UPDATA	; Update DATA pointer if "READ"
1C2A    D5              	PUSH	DE		; Save code string address
1C2B    B6              	OR	(HL)		; More input given?
1C2C    21 34 1C        	LD	HL,EXTIG	; "?Extra ignored" message
1C2F    C4 8D 21        	CALL	NZ,PRS		; Output string if extra given
1C32    E1              	POP	HL		; Restore code string address
1C33    C9              	RET
1C34                    ;
1C34    3F 45 78 74     EXTIG:	DB	"?Extra ignored",CR,LF,0
1C38    72 61 20 69
1C3C    67 6E 6F 72
1C40    65 64 0D 0A
1C44    00
1C45                    ;
1C45    CD DE 19        FDTLP:	CALL	DATA		; Get next statement
1C48    B7              	OR	A		; End of line?
1C49    C2 5E 1C        	JP	NZ,FANDT	; No - See if DATA statement
1C4C    23              	INC	HL
1C4D    7E              	LD	A,(HL)		; End of program?
1C4E    23              	INC	HL
1C4F    B6              	OR	(HL)		; 00 00 Ends program
1C50    1E 06           	LD	E,OD		; ?OD Error
1C52    CA 03 14        	JP	Z,ERROR_	; Yes - Out of DATA
1C55    23              	INC	HL
1C56    5E              	LD	E,(HL)		; LSB of line number
1C57    23              	INC	HL
1C58    56              	LD	D,(HL)		; MSB of line number
1C59    EB              	EX	DE,HL
1C5A    22 0E C1        	LD	(DATLIN),HL	; Set line of current DATA item
1C5D    EB              	EX	DE,HL
1C5E    CD 47 18        FANDT:	CALL	GETCHR		; Get next character
1C61    FE 83           	CP	ZDATA		; "DATA" token
1C63    C2 45 1C        	JP	NZ,FDTLP	; No "DATA" - Keep looking
1C66    C3 D8 1B        	JP	ANTVLU		; Found - Convert input
1C69                    ;
1C69    11 00 00        NEXT:	LD	DE,0		; In case no index given
1C6C    C4 AA 1E        NEXT1:	CALL	NZ,GETVAR	; Get index address
1C6F    22 13 C1        	LD	(BRKLIN),HL	; Save code string address
1C72    CD 98 13        	CALL	BAKSTK		; Look for "FOR" block
1C75    C2 F5 13        	JP	NZ,NFERR	; No "FOR" - ?NF Error
1C78    F9              	LD	SP,HL		; Clear nested loops
1C79    D5              	PUSH	DE		; Save index address
1C7A    7E              	LD	A,(HL)		; Get sign of STEP
1C7B    23              	INC	HL
1C7C    F5              	PUSH	AF		; Save sign of STEP
1C7D    D5              	PUSH	DE		; Save index address
1C7E    CD D4 26        	CALL	PHLTFP		; Move index value to FPREG
1C81    E3              	EX	(SP),HL		; Save address of TO value
1C82    E5              	PUSH	HL		; Save address of index
1C83    CD 41 24        	CALL	ADDPHL		; Add STEP to index value
1C86    E1              	POP	HL		; Restore address of index
1C87    CD EE 26        	CALL	FPTHL		; Move value to index variable
1C8A    E1              	POP	HL		; Restore address of TO value
1C8B    CD E5 26        	CALL	LOADFP		; Move TO value to BCDE
1C8E    E5              	PUSH	HL		; Save address of line of FOR
1C8F    CD 11 27        	CALL	CMPNUM		; Compare index with TO value
1C92    E1              	POP	HL		; Restore address of line num
1C93    C1              	POP	BC		; Address of sign of STEP
1C94    90              	SUB	B		; Compare with expected sign
1C95    CD E5 26        	CALL	LOADFP		; BC = Loop stmt,DE = Line num
1C98    CA A4 1C        	JP	Z,KILFOR	; Loop finished - Terminate it
1C9B    EB              	EX	DE,HL		; Loop statement line number
1C9C    22 A1 C0        	LD	(LINEAT),HL	; Set loop line number
1C9F    69              	LD	L,C		; Set code string to loop
1CA0    60              	LD	H,B
1CA1    C3 03 18        	JP	PUTFID		; Put back "FOR" and continue
1CA4                    ;
1CA4    F9              KILFOR: LD	SP,HL		; Remove "FOR" block
1CA5    2A 13 C1        	LD	HL,(BRKLIN)	; Code string after "NEXT"
1CA8    7E              	LD	A,(HL)		; Get next byte in code string
1CA9    FE 2C           	CP	','		; More NEXTs ?
1CAB    C2 07 18        	JP	NZ,RUNCNT	; No - Do next statement
1CAE    CD 47 18        	CALL	GETCHR		; Position to index name
1CB1    CD 6C 1C        	CALL	NEXT1		; Re-enter NEXT routine
1CB4                    ; < will not RETurn to here , Exit to RUNCNT or Loop >
1CB4                    ;
1CB4    CD C6 1C        GETNUM: CALL	EVAL		; Get a numeric expression
1CB7    F6              TSTNUM: DB	0F6H		; Clear carry (numeric)
1CB8    37              TSTSTR: SCF			; Set carry (string)
1CB9    3A F2 C0        CHKTYP: LD	A,(TYPE)	; Check types match
1CBC    8F              	ADC	A,A		; Expected + actual
1CBD    B7              	OR	A		; Clear carry , set parity
1CBE    E8              	RET	PE		; Even parity - Types match
1CBF    C3 01 14        	JP	TMERR		; Different types - Error
1CC2                    ;
1CC2    CD BD 16        OPNPAR: CALL	CHKSYN		; Make sure "(" follows
1CC5    28              	DB	"("
1CC6    2B              EVAL:	DEC	HL		; Evaluate expression & save
1CC7    16 00           	LD	D,0		; Precedence value
1CC9    D5              EVAL1:	PUSH	DE		; Save precedence
1CCA    0E 01           	LD	C,1
1CCC    CD CC 13        	CALL	CHKSTK		; Check for 1 level of stack
1CCF    CD 3D 1D        	CALL	OPRND		; Get next expression value
1CD2    22 15 C1        EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
1CD5    2A 15 C1        EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
1CD8    C1              	POP	BC		; Precedence value and operator
1CD9    78              	LD	A,B		; Get precedence value
1CDA    FE 78           	CP	78H		; "AND" or "OR" ?
1CDC    D4 B7 1C        	CALL	NC,TSTNUM	; No - Make sure it's a number
1CDF    7E              	LD	A,(HL)		; Get next operator / function
1CE0    16 00           	LD	D,0		; Clear Last relation
1CE2    D6 B3           RLTLP:	SUB	ZGTR		; ">" Token
1CE4    DA FE 1C        	JP	C,FOPRND	; + - * / ^ AND OR - Test it
1CE7    FE 03           	CP	ZLTH+1-ZGTR	; < = >
1CE9    D2 FE 1C        	JP	NC,FOPRND	; Function - Call it
1CEC    FE 01           	CP	ZEQUAL-ZGTR	; "="
1CEE    17              	RLA			; <- Test for legal
1CEF    AA              	XOR	D		; <- combinations of < = >
1CF0    BA              	CP	D		; <- by combining last token
1CF1    57              	LD	D,A		; <- with current one
1CF2    DA EF 13        	JP	C,SNERR		; Error if "<<' '==" or ">>"
1CF5    22 0A C1        	LD	(CUROPR),HL	; Save address of current token
1CF8    CD 47 18        	CALL	GETCHR		; Get next character
1CFB    C3 E2 1C        	JP	RLTLP		; Treat the two as one
1CFE                    ;
1CFE    7A              FOPRND: LD	A,D		; < = > found ?
1CFF    B7              	OR	A
1D00    C2 25 1E        	JP	NZ,TSTRED	; Yes - Test for reduction
1D03    7E              	LD	A,(HL)		; Get operator token
1D04    22 0A C1        	LD	(CUROPR),HL	; Save operator address
1D07    D6 AC           	SUB	ZPLUS		; Operator or function?
1D09    D8              	RET	C		; Neither - Exit
1D0A    FE 07           	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
1D0C    D0              	RET	NC		; No - Exit
1D0D    5F              	LD	E,A		; Coded operator
1D0E    3A F2 C0        	LD	A,(TYPE)	; Get data type
1D11    3D              	DEC	A		; FF = numeric , 00 = string
1D12    B3              	OR	E		; Combine with coded operator
1D13    7B              	LD	A,E		; Get coded operator
1D14    CA 83 22        	JP	Z,CONCAT	; String concatenation
1D17    07              	RLCA			; Times 2
1D18    83              	ADD	A,E		; Times 3
1D19    5F              	LD	E,A		; To DE (D is 0)
1D1A    21 E1 12        	LD	HL,PRITAB	; Precedence table
1D1D    19              	ADD	HL,DE		; To the operator concerned
1D1E    78              	LD	A,B		; Last operator precedence
1D1F    56              	LD	D,(HL)		; Get evaluation precedence
1D20    BA              	CP	D		; Compare with eval precedence
1D21    D0              	RET	NC		; Exit if higher precedence
1D22    23              	INC	HL		; Point to routine address
1D23    CD B7 1C        	CALL	TSTNUM		; Make sure it's a number
1D26                    ;
1D26    C5              STKTHS: PUSH	BC		; Save last precedence & token
1D27    01 D5 1C        	LD	BC,EVAL3	; Where to go on prec' break
1D2A    C5              	PUSH	BC		; Save on stack for return
1D2B    43              	LD	B,E		; Save operator
1D2C    4A              	LD	C,D		; Save precedence
1D2D    CD C7 26        	CALL	STAKFP		; Move value to stack
1D30    58              	LD	E,B		; Restore operator
1D31    51              	LD	D,C		; Restore precedence
1D32    4E              	LD	C,(HL)		; Get LSB of routine address
1D33    23              	INC	HL
1D34    46              	LD	B,(HL)		; Get MSB of routine address
1D35    23              	INC	HL
1D36    C5              	PUSH	BC		; Save routine address
1D37    2A 0A C1        	LD	HL,(CUROPR)	; Address of current operator
1D3A    C3 C9 1C        	JP	EVAL1		; Loop until prec' break
1D3D                    ;
1D3D    AF              OPRND:	XOR	A		; Get operand routine
1D3E    32 F2 C0        	LD	(TYPE),A	; Set numeric expected
1D41    CD 47 18        	CALL	GETCHR		; Get next character
1D44    1E 24           	LD	E,MO		; ?MO Error
1D46    CA 03 14        	JP	Z,ERROR_	; No operand - Error
1D49    DA 9D 27        	JP	C,ASCTFP	; Number - Get value
1D4C    CD E5 18        	CALL	CHKLTR		; See if a letter
1D4F    D2 A4 1D        	JP	NC,CONVAR	; Letter - Find variable
1D52    FE 26           	CP	'&'		; &H = HEX, &B = BINARY
1D54    20 12           	JR	NZ, NOTAMP
1D56    CD 47 18        	CALL	GETCHR		; Get next character
1D59    FE 48           	CP	'H'		; Hex number indicated? [function added]
1D5B    CA E1 2B        	JP	Z,HEXTFP	; Convert Hex to FPREG
1D5E    FE 42           	CP	'B'		; Binary number indicated? [function added]
1D60    CA 51 2C        	JP	Z,BINTFP	; Convert Bin to FPREG
1D63    1E 02           	LD	E,SN		; If neither then a ?SN Error
1D65    CA 03 14        	JP	Z,ERROR_
1D68    FE AC           NOTAMP: CP	ZPLUS		; '+' Token ?
1D6A    CA 3D 1D        	JP	Z,OPRND		; Yes - Look for operand
1D6D    FE 2E           	CP	'.'		; '.' ?
1D6F    CA 9D 27        	JP	Z,ASCTFP	; Yes - Create FP number
1D72    FE AD           	CP	ZMINUS		; '-' Token ?
1D74    CA 93 1D        	JP	Z,MINUS		; Yes - Do minus
1D77    FE 22           	CP	'"'		; Literal string ?
1D79    CA 4C 21        	JP	Z,QTSTR		; Get string terminated by '"'
1D7C    FE AA           	CP	ZNOT		; "NOT" Token ?
1D7E    CA 85 1E        	JP	Z,EVNOT		; Yes - Eval NOT expression
1D81    FE A7           	CP	ZFN		; "FN" Token ?
1D83    CA B0 20        	JP	Z,DOFN		; Yes - Do FN routine
1D86    D6 B6           	SUB	ZSGN		; Is it a function?
1D88    D2 B5 1D        	JP	NC,FNOFST	; Yes - Evaluate function
1D8B    CD C2 1C        EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
1D8E    CD BD 16        	CALL	CHKSYN		; Make sure ")" follows
1D91    29              	DB	")"
1D92    C9              	RET
1D93                    ;
1D93    16 7D           MINUS:	LD	D,7DH		; '-' precedence
1D95    CD C9 1C        	CALL	EVAL1		; Evaluate until prec' break
1D98    2A 15 C1        	LD	HL,(NXTOPR)	; Get next operator address
1D9B    E5              	PUSH	HL		; Save next operator address
1D9C    CD BF 26        	CALL	INVSGN		; Negate value
1D9F    CD B7 1C        RETNUM: CALL	TSTNUM		; Make sure it's a number
1DA2    E1              	POP	HL		; Restore next operator address
1DA3    C9              	RET
1DA4                    ;
1DA4    CD AA 1E        CONVAR: CALL	GETVAR		; Get variable address to DE
1DA7    E5              FRMEVL: PUSH	HL		; Save code string address
1DA8    EB              	EX	DE,HL		; Variable address to HL
1DA9    22 29 C1        	LD	(FPREG),HL	; Save address of variable
1DAC    3A F2 C0        	LD	A,(TYPE)	; Get type
1DAF    B7              	OR	A		; Numeric?
1DB0    CC D4 26        	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
1DB3    E1              	POP	HL		; Restore code string address
1DB4    C9              	RET
1DB5                    ;
1DB5    06 00           FNOFST: LD	B,0		; Get address of function
1DB7    07              	RLCA			; Double function offset
1DB8    4F              	LD	C,A		; BC = Offset in function table
1DB9    C5              	PUSH	BC		; Save adjusted token value
1DBA    CD 47 18        	CALL	GETCHR		; Get next character
1DBD    79              	LD	A,C		; Get adjusted token value
1DBE    FE 31           	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1DC0    DA DC 1D        	JP	C,FNVAL		; No - Do function
1DC3    CD C2 1C        	CALL	OPNPAR		; Evaluate expression	(X,...
1DC6    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
1DC9    2C              	DB	','
1DCA    CD B8 1C        	CALL	TSTSTR		; Make sure it's a string
1DCD    EB              	EX	DE,HL		; Save code string address
1DCE    2A 29 C1        	LD	HL,(FPREG)	; Get address of string
1DD1    E3              	EX	(SP),HL		; Save address of string
1DD2    E5              	PUSH	HL		; Save adjusted token value
1DD3    EB              	EX	DE,HL		; Restore code string address
1DD4    CD 15 24        	CALL	GETINT		; Get integer 0-255
1DD7    EB              	EX	DE,HL		; Save code string address
1DD8    E3              	EX	(SP),HL		; Save integer,HL = adj' token
1DD9    C3 E4 1D        	JP	GOFUNC		; Jump to string function
1DDC                    ;
1DDC    CD 8B 1D        FNVAL:	CALL	EVLPAR		; Evaluate expression
1DDF    E3              	EX	(SP),HL		; HL = Adjusted token value
1DE0    11 9F 1D        	LD	DE,RETNUM	; Return number from function
1DE3    D5              	PUSH	DE		; Save on stack
1DE4    01 40 11        GOFUNC: LD	BC,FNCTAB	; Function routine addresses
1DE7    09              	ADD	HL,BC		; Point to right address
1DE8    4E              	LD	C,(HL)		; Get LSB of address
1DE9    23              	INC	HL		;
1DEA    66              	LD	H,(HL)		; Get MSB of address
1DEB    69              	LD	L,C		; Address to HL
1DEC    E9              	JP	(HL)		; Jump to function
1DED                    ;
1DED    15              SGNEXP: DEC	D		; Dee to flag negative exponent
1DEE    FE AD           	CP	ZMINUS		; '-' token ?
1DF0    C8              	RET	Z		; Yes - Return
1DF1    FE 2D           	CP	'-'		; '-' ASCII ?
1DF3    C8              	RET	Z		; Yes - Return
1DF4    14              	INC	D		; Inc to flag positive exponent
1DF5    FE 2B           	CP	'+'		; '+' ASCII ?
1DF7    C8              	RET	Z		; Yes - Return
1DF8    FE AC           	CP	ZPLUS		; '+' token ?
1DFA    C8              	RET	Z		; Yes - Return
1DFB    2B              	DEC	HL		; DEC 'cos GETCHR INCs
1DFC    C9              	RET			; Return "NZ"
1DFD                    ;
1DFD    F6              POR:	DB	0F6H		; Flag "OR"
1DFE    AF              PAND:	XOR	A		; Flag "AND"
1DFF    F5              	PUSH	AF		; Save "AND" / "OR" flag
1E00    CD B7 1C        	CALL	TSTNUM		; Make sure it's a number
1E03    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
1E06    F1              	POP	AF		; Restore "AND" / "OR" flag
1E07    EB              	EX	DE,HL		; <- Get last
1E08    C1              	POP	BC		; <- value
1E09    E3              	EX	(SP),HL		; <- from
1E0A    EB              	EX	DE,HL		; <- stack
1E0B    CD D7 26        	CALL	FPBCDE		; Move last value to FPREG
1E0E    F5              	PUSH	AF		; Save "AND" / "OR" flag
1E0F    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
1E12    F1              	POP	AF		; Restore "AND" / "OR" flag
1E13    C1              	POP	BC		; Get value
1E14    79              	LD	A,C		; Get LSB
1E15    21 6E 20        	LD	HL,ACPASS	; Address of save AC as current
1E18    C2 20 1E        	JP	NZ,POR1		; Jump if OR
1E1B    A3              	AND	E		; "AND" LSBs
1E1C    4F              	LD	C,A		; Save LSB
1E1D    78              	LD	A,B		; Get MBS
1E1E    A2              	AND	D		; "AND" MSBs
1E1F    E9              	JP	(HL)		; Save AC as current (ACPASS)
1E20                    ;
1E20    B3              POR1:	OR	E		; "OR" LSBs
1E21    4F              	LD	C,A		; Save LSB
1E22    78              	LD	A,B		; Get MSB
1E23    B2              	OR	D		; "OR" MSBs
1E24    E9              	JP	(HL)		; Save AC as current (ACPASS)
1E25                    ;
1E25    21 37 1E        TSTRED: LD	HL,CMPLOG	; Logical compare routine
1E28    3A F2 C0        	LD	A,(TYPE)	; Get data type
1E2B    1F              	RRA			; Carry set = string
1E2C    7A              	LD	A,D		; Get last precedence value
1E2D    17              	RLA			; Times 2 plus carry
1E2E    5F              	LD	E,A		; To E
1E2F    16 64           	LD	D,64H		; Relational precedence
1E31    78              	LD	A,B		; Get current precedence
1E32    BA              	CP	D		; Compare with last
1E33    D0              	RET	NC		; Eval if last was rel' or log'
1E34    C3 26 1D        	JP	STKTHS		; Stack this one and get next
1E37                    ;
1E37    39 1E           CMPLOG: DW	CMPLG1		; Compare two values / strings
1E39    79              CMPLG1: LD	A,C		; Get data type
1E3A    B7              	OR	A
1E3B    1F              	RRA
1E3C    C1              	POP	BC		; Get last expression to BCDE
1E3D    D1              	POP	DE
1E3E    F5              	PUSH	AF		; Save status
1E3F    CD B9 1C        	CALL	CHKTYP		; Check that types match
1E42    21 7B 1E        	LD	HL,CMPRES	; Result to comparison
1E45    E5              	PUSH	HL		; Save for RETurn
1E46    CA 11 27        	JP	Z,CMPNUM	; Compare values if numeric
1E49    AF              	XOR	A		; Compare two strings
1E4A    32 F2 C0        	LD	(TYPE),A	; Set type to numeric
1E4D    D5              	PUSH	DE		; Save string name
1E4E    CD D0 22        	CALL	GSTRCU		; Get current string
1E51    7E              	LD	A,(HL)		; Get length of string
1E52    23              	INC	HL
1E53    23              	INC	HL
1E54    4E              	LD	C,(HL)		; Get LSB of address
1E55    23              	INC	HL
1E56    46              	LD	B,(HL)		; Get MSB of address
1E57    D1              	POP	DE		; Restore string name
1E58    C5              	PUSH	BC		; Save address of string
1E59    F5              	PUSH	AF		; Save length of string
1E5A    CD D4 22        	CALL	GSTRDE		; Get second string
1E5D    CD E5 26        	CALL	LOADFP		; Get address of second string
1E60    F1              	POP	AF		; Restore length of string 1
1E61    57              	LD	D,A		; Length to D
1E62    E1              	POP	HL		; Restore address of string 1
1E63    7B              CMPSTR: LD	A,E		; Bytes of string 2 to do
1E64    B2              	OR	D		; Bytes of string 1 to do
1E65    C8              	RET	Z		; Exit if all bytes compared
1E66    7A              	LD	A,D		; Get bytes of string 1 to do
1E67    D6 01           	SUB	1
1E69    D8              	RET	C		; Exit if end of string 1
1E6A    AF              	XOR	A
1E6B    BB              	CP	E		; Bytes of string 2 to do
1E6C    3C              	INC	A
1E6D    D0              	RET	NC		; Exit if end of string 2
1E6E    15              	DEC	D		; Count bytes in string 1
1E6F    1D              	DEC	E		; Count bytes in string 2
1E70    0A              	LD	A,(BC)		; Byte in string 2
1E71    BE              	CP	(HL)		; Compare to byte in string 1
1E72    23              	INC	HL		; Move up string 1
1E73    03              	INC	BC		; Move up string 2
1E74    CA 63 1E        	JP	Z,CMPSTR	; Same - Try next bytes
1E77    3F              	CCF			; Flag difference (">" or "<")
1E78    C3 A1 26        	JP	FLGDIF		; "<" gives -1 , ">" gives +1
1E7B                    ;
1E7B    3C              CMPRES: INC	A		; Increment current value
1E7C    8F              	ADC	A,A		; Double plus carry
1E7D    C1              	POP	BC		; Get other value
1E7E    A0              	AND	B		; Combine them
1E7F    C6 FF           	ADD	A,-1		; Carry set if different
1E81    9F              	SBC	A,A		; 00 - Equal , FF - Different
1E82    C3 A8 26        	JP	FLGREL		; Set current value & continue
1E85                    ;
1E85    16 5A           EVNOT:	LD	D,5AH		; Precedence value for "NOT"
1E87    CD C9 1C        	CALL	EVAL1		; Eval until precedence break
1E8A    CD B7 1C        	CALL	TSTNUM		; Make sure it's a number
1E8D    CD F9 18        	CALL	DEINT		; Get integer -32768 - 32767
1E90    7B              	LD	A,E		; Get LSB
1E91    2F              	CPL			; Invert LSB
1E92    4F              	LD	C,A		; Save "NOT" of LSB
1E93    7A              	LD	A,D		; Get MSB
1E94    2F              	CPL			; Invert MSB
1E95    CD 6E 20        	CALL	ACPASS		; Save AC as current
1E98    C1              	POP	BC		; Clean up stack
1E99    C3 D5 1C        	JP	EVAL3		; Continue evaluation
1E9C                    ;
1E9C    2B              DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
1E9D    CD 47 18        	CALL	GETCHR		; Get next character
1EA0    C8              	RET	Z		; End of DIM statement
1EA1    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
1EA4    2C              	DB	','
1EA5    01 9C 1E        DIM:	LD	BC,DIMRET	; Return to "DIMRET"
1EA8    C5              	PUSH	BC		; Save on stack
1EA9    F6              	DB	0F6H		; Flag "Create" variable
1EAA    AF              GETVAR: XOR	A		; Find variable address,to DE
1EAB    32 F1 C0        	LD	(LCRFLG),A	; Set locate / create flag
1EAE    46              	LD	B,(HL)		; Get First byte of name
1EAF    CD E5 18        GTFNAM: CALL	CHKLTR		; See if a letter
1EB2    DA EF 13        	JP	C,SNERR		; ?SN Error if not a letter
1EB5    AF              	XOR	A
1EB6    4F              	LD	C,A		; Clear second byte of name
1EB7    32 F2 C0        	LD	(TYPE),A	; Set type to numeric
1EBA    CD 47 18        	CALL	GETCHR		; Get next character
1EBD    DA C6 1E        	JP	C,SVNAM2	; Numeric - Save in name
1EC0    CD E5 18        	CALL	CHKLTR		; See if a letter
1EC3    DA D3 1E        	JP	C,CHARTY	; Not a letter - Check type
1EC6    4F              SVNAM2: LD	C,A		; Save second byte of name
1EC7    CD 47 18        ENDNAM: CALL	GETCHR		; Get next character
1ECA    DA C7 1E        	JP	C,ENDNAM	; Numeric - Get another
1ECD    CD E5 18        	CALL	CHKLTR		; See if a letter
1ED0    D2 C7 1E        	JP	NC,ENDNAM	; Letter - Get another
1ED3    D6 24           CHARTY: SUB	'$'		; String variable?
1ED5    C2 E2 1E        	JP	NZ,NOTSTR	; No - Numeric variable
1ED8    3C              	INC	A		; A = 1 (string type)
1ED9    32 F2 C0        	LD	(TYPE),A	; Set type to string
1EDC    0F              	RRCA			; A = 80H , Flag for string
1EDD    81              	ADD	A,C		; 2nd byte of name has bit 7 on
1EDE    4F              	LD	C,A		; Resave second byte on name
1EDF    CD 47 18        	CALL	GETCHR		; Get next character
1EE2    3A 10 C1        NOTSTR: LD	A,(FORFLG)	; Array name needed ?
1EE5    3D              	DEC	A
1EE6    CA 8F 1F        	JP	Z,ARLDSV	; Yes - Get array name
1EE9    F2 F2 1E        	JP	P,NSCFOR	; No array with "FOR" or "FN"
1EEC    7E              	LD	A,(HL)		; Get byte again
1EED    D6 28           	SUB	'('		; Subscripted variable?
1EEF    CA 67 1F        	JP	Z,SBSCPT	; Yes - Sort out subscript
1EF2                    ;
1EF2    AF              NSCFOR: XOR	A		; Simple variable
1EF3    32 10 C1        	LD	(FORFLG),A	; Clear "FOR" flag
1EF6    E5              	PUSH	HL		; Save code string address
1EF7    50              	LD	D,B		; DE = Variable name to find
1EF8    59              	LD	E,C
1EF9    2A 23 C1        	LD	HL,(FNRGNM)	; FN argument name
1EFC    CD B7 16        	CALL	CPDEHL		; Is it the FN argument?
1EFF    11 25 C1        	LD	DE,FNARG	; Point to argument value
1F02    CA D7 25        	JP	Z,POPHRT	; Yes - Return FN argument value
1F05    2A 1D C1        	LD	HL,(VAREND)	; End of variables
1F08    EB              	EX	DE,HL		; Address of end of search
1F09    2A 1B C1        	LD	HL,(PROGND)	; Start of variables address
1F0C    CD B7 16        FNDVAR: CALL	CPDEHL		; End of variable list table?
1F0F    CA 25 1F        	JP	Z,CFEVAL	; Yes - Called from EVAL?
1F12    79              	LD	A,C		; Get second byte of name
1F13    96              	SUB	(HL)		; Compare with name in list
1F14    23              	INC	HL		; Move on to first byte
1F15    C2 1A 1F        	JP	NZ,FNTHR	; Different - Find another
1F18    78              	LD	A,B		; Get first byte of name
1F19    96              	SUB	(HL)		; Compare with name in list
1F1A    23              FNTHR:	INC	HL		; Move on to LSB of value
1F1B    CA 59 1F        	JP	Z,RETADR	; Found - Return address
1F1E    23              	INC	HL		; <- Skip
1F1F    23              	INC	HL		; <- over
1F20    23              	INC	HL		; <- F.P.
1F21    23              	INC	HL		; <- value
1F22    C3 0C 1F        	JP	FNDVAR		; Keep looking
1F25                    ;
1F25    E1              CFEVAL: POP	HL		; Restore code string address
1F26    E3              	EX	(SP),HL		; Get return address
1F27    D5              	PUSH	DE		; Save address of variable
1F28    11 A7 1D        	LD	DE,FRMEVL	; Return address in EVAL
1F2B    CD B7 16        	CALL	CPDEHL		; Called from EVAL ?
1F2E    D1              	POP	DE		; Restore address of variable
1F2F    CA 5C 1F        	JP	Z,RETNUL	; Yes - Return null variable
1F32    E3              	EX	(SP),HL		; Put back return
1F33    E5              	PUSH	HL		; Save code string address
1F34    C5              	PUSH	BC		; Save variable name
1F35    01 06 00        	LD	BC,6		; 2 byte name plus 4 byte data
1F38    2A 1F C1        	LD	HL,(ARREND)	; End of arrays
1F3B    E5              	PUSH	HL		; Save end of arrays
1F3C    09              	ADD	HL,BC		; Move up 6 bytes
1F3D    C1              	POP	BC		; Source address in BC
1F3E    E5              	PUSH	HL		; Save new end address
1F3F    CD BB 13        	CALL	MOVUP		; Move arrays up
1F42    E1              	POP	HL		; Restore new end address
1F43    22 1F C1        	LD	(ARREND),HL	; Set new end address
1F46    60              	LD	H,B		; End of variables to HL
1F47    69              	LD	L,C
1F48    22 1D C1        	LD	(VAREND),HL	; Set new end address
1F4B                    ;
1F4B    2B              ZEROLP: DEC	HL		; Back through to zero variable
1F4C    36 00           	LD	(HL),0		; Zero byte in variable
1F4E    CD B7 16        	CALL	CPDEHL		; Done them all?
1F51    C2 4B 1F        	JP	NZ,ZEROLP	; No - Keep on going
1F54    D1              	POP	DE		; Get variable name
1F55    73              	LD	(HL),E		; Store second character
1F56    23              	INC	HL
1F57    72              	LD	(HL),D		; Store first character
1F58    23              	INC	HL
1F59    EB              RETADR: EX	DE,HL		; Address of variable in DE
1F5A    E1              	POP	HL		; Restore code string address
1F5B    C9              	RET
1F5C                    ;
1F5C    32 2C C1        RETNUL: LD	(FPEXP),A	; Set result to zero
1F5F    21 8B 13        	LD	HL,ZERBYT	; Also set a null string
1F62    22 29 C1        	LD	(FPREG),HL	; Save for EVAL
1F65    E1              	POP	HL		; Restore code string address
1F66    C9              	RET
1F67                    ;
1F67    E5              SBSCPT: PUSH	HL		; Save code string address
1F68    2A F1 C0        	LD	HL,(LCRFLG)	; Locate/Create and Type
1F6B    E3              	EX	(SP),HL		; Save and get code string
1F6C    57              	LD	D,A		; Zero number of dimensions
1F6D    D5              SCPTLP: PUSH	DE		; Save number of dimensions
1F6E    C5              	PUSH	BC		; Save array name
1F6F    CD ED 18        	CALL	FPSINT		; Get subscript (0-32767)
1F72    C1              	POP	BC		; Restore array name
1F73    F1              	POP	AF		; Get number of dimensions
1F74    EB              	EX	DE,HL
1F75    E3              	EX	(SP),HL		; Save subscript value
1F76    E5              	PUSH	HL		; Save LCRFLG and TYPE
1F77    EB              	EX	DE,HL
1F78    3C              	INC	A		; Count dimensions
1F79    57              	LD	D,A		; Save in D
1F7A    7E              	LD	A,(HL)		; Get next byte in code string
1F7B    FE 2C           	CP	','		; Comma (more to come)?
1F7D    CA 6D 1F        	JP	Z,SCPTLP	; Yes - More subscripts
1F80    CD BD 16        	CALL	CHKSYN		; Make sure ")" follows
1F83    29              	DB	")"
1F84    22 15 C1        	LD	(NXTOPR),HL	; Save code string address
1F87    E1              	POP	HL		; Get LCRFLG and TYPE
1F88    22 F1 C0        	LD	(LCRFLG),HL	; Restore Locate/create & type
1F8B    1E 00           	LD	E,0		; Flag not CSAVE* or CLOAD*
1F8D    D5              	PUSH	DE		; Save number of dimensions (D)
1F8E    11              	DB	11H		; Skip "PUSH HL" and "PUSH AF'
1F8F                    ;
1F8F    E5              ARLDSV: PUSH	HL		; Save code string address
1F90    F5              	PUSH	AF		; A = 00 , Flags set = Z,N
1F91    2A 1D C1        	LD	HL,(VAREND)	; Start of arrays
1F94    3E              	DB	3EH		; Skip "ADD HL,DE"
1F95    19              FNDARY: ADD	HL,DE		; Move to next array start
1F96    EB              	EX	DE,HL
1F97    2A 1F C1        	LD	HL,(ARREND)	; End of arrays
1F9A    EB              	EX	DE,HL		; Current array pointer
1F9B    CD B7 16        	CALL	CPDEHL		; End of arrays found?
1F9E    CA C7 1F        	JP	Z,CREARY	; Yes - Create array
1FA1    7E              	LD	A,(HL)		; Get second byte of name
1FA2    B9              	CP	C		; Compare with name given
1FA3    23              	INC	HL		; Move on
1FA4    C2 A9 1F        	JP	NZ,NXTARY	; Different - Find next array
1FA7    7E              	LD	A,(HL)		; Get first byte of name
1FA8    B8              	CP	B		; Compare with name given
1FA9    23              NXTARY: INC	HL		; Move on
1FAA    5E              	LD	E,(HL)		; Get LSB of next array address
1FAB    23              	INC	HL
1FAC    56              	LD	D,(HL)		; Get MSB of next array address
1FAD    23              	INC	HL
1FAE    C2 95 1F        	JP	NZ,FNDARY	; Not found - Keep looking
1FB1    3A F1 C0        	LD	A,(LCRFLG)	; Found Locate or Create it?
1FB4    B7              	OR	A
1FB5    C2 F8 13        	JP	NZ,DDERR	; Create - ?DD Error
1FB8    F1              	POP	AF		; Locate - Get number of dim'ns
1FB9    44              	LD	B,H		; BC Points to array dim'ns
1FBA    4D              	LD	C,L
1FBB    CA D7 25        	JP	Z,POPHRT	; Jump if array load/save
1FBE    96              	SUB	(HL)		; Same number of dimensions?
1FBF    CA 25 20        	JP	Z,FINDEL	; Yes - Find element
1FC2    1E 10           BSERR:	LD	E,BS		; ?BS Error
1FC4    C3 03 14        	JP	ERROR_		; Output error
1FC7                    ;
1FC7    11 04 00        CREARY: LD	DE,4		; 4 Bytes per entry
1FCA    F1              	POP	AF		; Array to save or 0 dim'ns?
1FCB    CA 0E 19        	JP	Z,FCERR		; Yes - ?FC Error
1FCE    71              	LD	(HL),C		; Save second byte of name
1FCF    23              	INC	HL
1FD0    70              	LD	(HL),B		; Save first byte of name
1FD1    23              	INC	HL
1FD2    4F              	LD	C,A		; Number of dimensions to C
1FD3    CD CC 13        	CALL	CHKSTK		; Check if enough memory
1FD6    23              	INC	HL		; Point to number of dimensions
1FD7    23              	INC	HL
1FD8    22 0A C1        	LD	(CUROPR),HL	; Save address of pointer
1FDB    71              	LD	(HL),C		; Set number of dimensions
1FDC    23              	INC	HL
1FDD    3A F1 C0        	LD	A,(LCRFLG)	; Locate of Create?
1FE0    17              	RLA			; Carry set = Create
1FE1    79              	LD	A,C		; Get number of dimensions
1FE2    01 0B 00        CRARLP: LD	BC,10+1		; Default dimension size 10
1FE5    D2 EA 1F        	JP	NC,DEFSIZ	; Locate - Set default size
1FE8    C1              	POP	BC		; Get specified dimension size
1FE9    03              	INC	BC		; Include zero element
1FEA    71              DEFSIZ: LD	(HL),C		; Save LSB of dimension size
1FEB    23              	INC	HL
1FEC    70              	LD	(HL),B		; Save MSB of dimension size
1FED    23              	INC	HL
1FEE    F5              	PUSH	AF		; Save num' of dim'ns an status
1FEF    E5              	PUSH	HL		; Save address of dim'n size
1FF0    CD 82 27        	CALL	MLDEBC		; Multiply DE by BC to find
1FF3    EB              	EX	DE,HL		; amount of mem needed (to DE)
1FF4    E1              	POP	HL		; Restore address of dimension
1FF5    F1              	POP	AF		; Restore number of dimensions
1FF6    3D              	DEC	A		; Count them
1FF7    C2 E2 1F        	JP	NZ,CRARLP	; Do next dimension if more
1FFA    F5              	PUSH	AF		; Save locate/create flag
1FFB    42              	LD	B,D		; MSB of memory needed
1FFC    4B              	LD	C,E		; LSB of memory needed
1FFD    EB              	EX	DE,HL
1FFE    19              	ADD	HL,DE		; Add bytes to array start
1FFF    DA E4 13        	JP	C,OMERR		; Too big - Error
2002    CD D5 13        	CALL	ENFMEM		; See if enough memory
2005    22 1F C1        	LD	(ARREND),HL	; Save new end of array
2008                    ;
2008    2B              ZERARY: DEC	HL		; Back through array data
2009    36 00           	LD	(HL),0		; Set array element to zero
200B    CD B7 16        	CALL	CPDEHL		; All elements zeroed?
200E    C2 08 20        	JP	NZ,ZERARY	; No - Keep on going
2011    03              	INC	BC		; Number of bytes + 1
2012    57              	LD	D,A		; A=0
2013    2A 0A C1        	LD	HL,(CUROPR)	; Get address of array
2016    5E              	LD	E,(HL)		; Number of dimensions
2017    EB              	EX	DE,HL		; To HL
2018    29              	ADD	HL,HL		; Two bytes per dimension size
2019    09              	ADD	HL,BC		; Add number of bytes
201A    EB              	EX	DE,HL		; Bytes needed to DE
201B    2B              	DEC	HL
201C    2B              	DEC	HL
201D    73              	LD	(HL),E		; Save LSB of bytes needed
201E    23              	INC	HL
201F    72              	LD	(HL),D		; Save MSB of bytes needed
2020    23              	INC	HL
2021    F1              	POP	AF		; Locate / Create?
2022    DA 49 20        	JP	C,ENDDIM	; A is 0 , End if create
2025    47              FINDEL: LD	B,A		; Find array element
2026    4F              	LD	C,A
2027    7E              	LD	A,(HL)		; Number of dimensions
2028    23              	INC	HL
2029    16              	DB	16H		; Skip "POP HL"
202A    E1              FNDELP: POP	HL		; Address of next dim' size
202B    5E              	LD	E,(HL)		; Get LSB of dim'n size
202C    23              	INC	HL
202D    56              	LD	D,(HL)		; Get MSB of dim'n size
202E    23              	INC	HL
202F    E3              	EX	(SP),HL		; Save address - Get index
2030    F5              	PUSH	AF		; Save number of dim'ns
2031    CD B7 16        	CALL	CPDEHL		; Dimension too large?
2034    D2 C2 1F        	JP	NC,BSERR	; Yes - ?BS Error
2037    E5              	PUSH	HL		; Save index
2038    CD 82 27        	CALL	MLDEBC		; Multiply previous by size
203B    D1              	POP	DE		; Index supplied to DE
203C    19              	ADD	HL,DE		; Add index to pointer
203D    F1              	POP	AF		; Number of dimensions
203E    3D              	DEC	A		; Count them
203F    44              	LD	B,H		; MSB of pointer
2040    4D              	LD	C,L		; LSB of pointer
2041    C2 2A 20        	JP	NZ,FNDELP	; More - Keep going
2044    29              	ADD	HL,HL		; 4 Bytes per element
2045    29              	ADD	HL,HL
2046    C1              	POP	BC		; Start of array
2047    09              	ADD	HL,BC		; Point to element
2048    EB              	EX	DE,HL		; Address of element to DE
2049    2A 15 C1        ENDDIM: LD	HL,(NXTOPR)	; Got code string address
204C    C9              	RET
204D                    ;
204D    2A 1F C1        FRE:	LD	HL,(ARREND)	; Start of free memory
2050    EB              	EX	DE,HL		; To DE
2051    21 00 00        	LD	HL,0		; End of free memory
2054    39              	ADD	HL,SP		; Current stack value
2055    3A F2 C0        	LD	A,(TYPE)	; Dummy argument type
2058    B7              	OR	A
2059    CA 69 20        	JP	Z,FRENUM	; Numeric - Free variable space
205C    CD D0 22        	CALL	GSTRCU		; Current string to pool
205F    CD D0 21        	CALL	GARBGE		; Garbage collection
2062    2A 9F C0        	LD	HL,(STRSPC)	; Bottom of string space in use
2065    EB              	EX	DE,HL		; To DE
2066    2A 08 C1        	LD	HL,(STRBOT)	; Bottom of string space
2069    7D              FRENUM: LD	A,L		; Get LSB of end
206A    93              	SUB	E		; Subtract LSB of beginning
206B    4F              	LD	C,A		; Save difference if C
206C    7C              	LD	A,H		; Get MSB of end
206D    9A              	SBC	A,D		; Subtract MSB of beginning
206E    41              ACPASS: LD	B,C		; Return integer AC
206F    50              ABPASS: LD	D,B		; Return integer AB
2070    1E 00           	LD	E,0
2072    21 F2 C0        	LD	HL,TYPE		; Point to type
2075    73              	LD	(HL),E		; Set type to numeric
2076    06 90           	LD	B,80H+16	; 16 bit integer
2078    C3 AD 26        	JP	RETINT		; Return the integr
207B                    ;
207B    3A F0 C0        POS:	LD	A,(CURPOS)	; Get cursor position
207E    47              PASSA:	LD	B,A		; Put A into AB
207F    AF              	XOR	A		; Zero A
2080    C3 6F 20        	JP	ABPASS		; Return integer AB
2083                    ;
2083    CD 06 21        DEF:	CALL	CHEKFN		; Get "FN" and name
2086    CD F8 20        	CALL	IDTEST		; Test for illegal direct
2089    01 DE 19        	LD	BC,DATA		; To get next statement
208C    C5              	PUSH	BC		; Save address for RETurn
208D    D5              	PUSH	DE		; Save address of function ptr
208E    CD BD 16        	CALL	CHKSYN		; Make sure "(" follows
2091    28              	DB	"("
2092    CD AA 1E        	CALL	GETVAR		; Get argument variable name
2095    E5              	PUSH	HL		; Save code string address
2096    EB              	EX	DE,HL		; Argument address to HL
2097    2B              	DEC	HL
2098    56              	LD	D,(HL)		; Get first byte of arg name
2099    2B              	DEC	HL
209A    5E              	LD	E,(HL)		; Get second byte of arg name
209B    E1              	POP	HL		; Restore code string address
209C    CD B7 1C        	CALL	TSTNUM		; Make sure numeric argument
209F    CD BD 16        	CALL	CHKSYN		; Make sure ")" follows
20A2    29              	DB	")"
20A3    CD BD 16        	CALL	CHKSYN		; Make sure "=" follows
20A6    B4              	DB	ZEQUAL		; "=" token
20A7    44              	LD	B,H		; Code string address to BC
20A8    4D              	LD	C,L
20A9    E3              	EX	(SP),HL		; Save code str , Get FN ptr
20AA    71              	LD	(HL),C		; Save LSB of FN code string
20AB    23              	INC	HL
20AC    70              	LD	(HL),B		; Save MSB of FN code string
20AD    C3 45 21        	JP	SVSTAD		; Save address and do function
20B0                    ;
20B0    CD 06 21        DOFN:	CALL	CHEKFN		; Make sure FN follows
20B3    D5              	PUSH	DE		; Save function pointer address
20B4    CD 8B 1D        	CALL	EVLPAR		; Evaluate expression in "()"
20B7    CD B7 1C        	CALL	TSTNUM		; Make sure numeric result
20BA    E3              	EX	(SP),HL		; Save code str , Get FN ptr
20BB    5E              	LD	E,(HL)		; Get LSB of FN code string
20BC    23              	INC	HL
20BD    56              	LD	D,(HL)		; Get MSB of FN code string
20BE    23              	INC	HL
20BF    7A              	LD	A,D		; And function DEFined?
20C0    B3              	OR	E
20C1    CA FB 13        	JP	Z,UFERR		; No - ?UF Error
20C4    7E              	LD	A,(HL)		; Get LSB of argument address
20C5    23              	INC	HL
20C6    66              	LD	H,(HL)		; Get MSB of argument address
20C7    6F              	LD	L,A		; HL = Arg variable address
20C8    E5              	PUSH	HL		; Save it
20C9    2A 23 C1        	LD	HL,(FNRGNM)	; Get old argument name
20CC    E3              	EX	(SP),HL;	; Save old , Get new
20CD    22 23 C1        	LD	(FNRGNM),HL	; Set new argument name
20D0    2A 27 C1        	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
20D3    E5              	PUSH	HL		; Save it
20D4    2A 25 C1        	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
20D7    E5              	PUSH	HL		; Save it
20D8    21 25 C1        	LD	HL,FNARG	; HL = Value of argument
20DB    D5              	PUSH	DE		; Save FN code string address
20DC    CD EE 26        	CALL	FPTHL		; Move FPREG to argument
20DF    E1              	POP	HL		; Get FN code string address
20E0    CD B4 1C        	CALL	GETNUM		; Get value from function
20E3    2B              	DEC	HL		; DEC 'cos GETCHR INCs
20E4    CD 47 18        	CALL	GETCHR		; Get next character
20E7    C2 EF 13        	JP	NZ,SNERR	; Bad character in FN - Error
20EA    E1              	POP	HL		; Get MSB,EXP of old arg
20EB    22 25 C1        	LD	(FNARG),HL	; Restore it
20EE    E1              	POP	HL		; Get LSB,NLSB of old arg
20EF    22 27 C1        	LD	(FNARG+2),HL	; Restore it
20F2    E1              	POP	HL		; Get name of old arg
20F3    22 23 C1        	LD	(FNRGNM),HL	; Restore it
20F6    E1              	POP	HL		; Restore code string address
20F7    C9              	RET
20F8                    ;
20F8    E5              IDTEST: PUSH	HL		; Save code string address
20F9    2A A1 C0        	LD	HL,(LINEAT)	; Get current line number
20FC    23              	INC	HL		; -1 means direct statement
20FD    7C              	LD	A,H
20FE    B5              	OR	L
20FF    E1              	POP	HL		; Restore code string address
2100    C0              	RET	NZ		; Return if in program
2101    1E 16           	LD	E,ID		; ?ID Error
2103    C3 03 14        	JP	ERROR_
2106                    ;
2106    CD BD 16        CHEKFN: CALL	CHKSYN		; Make sure FN follows
2109    A7              	DB	ZFN		; "FN" token
210A    3E 80           	LD	A,80H
210C    32 10 C1        	LD	(FORFLG),A	; Flag FN name to find
210F    B6              	OR	(HL)		; FN name has bit 7 set
2110    47              	LD	B,A		; in first byte of name
2111    CD AF 1E        	CALL	GTFNAM		; Get FN name
2114    C3 B7 1C        	JP	TSTNUM		; Make sure numeric function
2117                    ;
2117    CD B7 1C        STR:	CALL	TSTNUM		; Make sure it's a number
211A    CD 3B 28        	CALL	NUMASC		; Turn number into text
211D    CD 4B 21        STR1:	CALL	CRTST		; Create string entry for it
2120    CD D0 22        	CALL	GSTRCU		; Current string to pool
2123    01 2B 23        	LD	BC,TOPOOL	; Save in string pool
2126    C5              	PUSH	BC		; Save address on stack
2127                    ;
2127    7E              SAVSTR: LD	A,(HL)		; Get string length
2128    23              	INC	HL
2129    23              	INC	HL
212A    E5              	PUSH	HL		; Save pointer to string
212B    CD A6 21        	CALL	TESTR		; See if enough string space
212E    E1              	POP	HL		; Restore pointer to string
212F    4E              	LD	C,(HL)		; Get LSB of address
2130    23              	INC	HL
2131    46              	LD	B,(HL)		; Get MSB of address
2132    CD 3F 21        	CALL	CRTMST		; Create string entry
2135    E5              	PUSH	HL		; Save pointer to MSB of addr
2136    6F              	LD	L,A		; Length of string
2137    CD C3 22        	CALL	TOSTRA		; Move to string area
213A    D1              	POP	DE		; Restore pointer to MSB
213B    C9              	RET
213C                    ;
213C    CD A6 21        MKTMST: CALL	TESTR		; See if enough string space
213F    21 04 C1        CRTMST: LD	HL,TMPSTR	; Temporary string
2142    E5              	PUSH	HL		; Save it
2143    77              	LD	(HL),A		; Save length of string
2144    23              	INC	HL
2145    23              SVSTAD: INC	HL
2146    73              	LD	(HL),E		; Save LSB of address
2147    23              	INC	HL
2148    72              	LD	(HL),D		; Save MSB of address
2149    E1              	POP	HL		; Restore pointer
214A    C9              	RET
214B                    ;
214B    2B              CRTST:	DEC	HL		; DEC - INCed after
214C    06 22           QTSTR:	LD	B,'"'		; Terminating quote
214E    50              	LD	D,B		; Quote to D
214F    E5              DTSTR:	PUSH	HL		; Save start
2150    0E FF           	LD	C,-1		; Set counter to -1
2152    23              QTSTLP: INC	HL		; Move on
2153    7E              	LD	A,(HL)		; Get byte
2154    0C              	INC	C		; Count bytes
2155    B7              	OR	A		; End of line?
2156    CA 61 21        	JP	Z,CRTSTE	; Yes - Create string entry
2159    BA              	CP	D		; Terminator D found?
215A    CA 61 21        	JP	Z,CRTSTE	; Yes - Create string entry
215D    B8              	CP	B		; Terminator B found?
215E    C2 52 21        	JP	NZ,QTSTLP	; No - Keep looking
2161    FE 22           CRTSTE: CP	'"'		; End with '"'?
2163    CC 47 18        	CALL	Z,GETCHR	; Yes - Get next character
2166    E3              	EX	(SP),HL		; Starting quote
2167    23              	INC	HL		; First byte of string
2168    EB              	EX	DE,HL		; To DE
2169    79              	LD	A,C		; Get length
216A    CD 3F 21        	CALL	CRTMST		; Create string entry
216D    11 04 C1        TSTOPL: LD	DE,TMPSTR	; Temporary string
2170    2A F6 C0        	LD	HL,(TMSTPT)	; Temporary string pool pointer
2173    22 29 C1        	LD	(FPREG),HL	; Save address of string ptr
2176    3E 01           	LD	A,1
2178    32 F2 C0        	LD	(TYPE),A	; Set type to string
217B    CD F1 26        	CALL	DETHL4		; Move string to pool
217E    CD B7 16        	CALL	CPDEHL		; Out of string pool?
2181    22 F6 C0        	LD	(TMSTPT),HL	; Save new pointer
2184    E1              	POP	HL		; Restore code string address
2185    7E              	LD	A,(HL)		; Get next code byte
2186    C0              	RET	NZ		; Return if pool OK
2187    1E 1E           	LD	E,ST		; ?ST Error
2189    C3 03 14        	JP	ERROR_		; String pool overflow
218C                    ;
218C    23              PRNUMS: INC	HL		; Skip leading space
218D    CD 4B 21        PRS:	CALL	CRTST		; Create string entry for it
2190    CD D0 22        PRS1:	CALL	GSTRCU		; Current string to pool
2193    CD E5 26        	CALL	LOADFP		; Move string block to BCDE
2196    1C              	INC	E		; Length + 1
2197    1D              PRSLP:	DEC	E		; Count characters
2198    C8              	RET	Z		; End of string
2199    0A              	LD	A,(BC)		; Get byte to output
219A    CD C8 16        	CALL	OUTC		; Output character in A
219D    FE 0D           	CP	CR		; Return?
219F    CC F9 1A        	CALL	Z,DONULL	; Yes - Do nulls
21A2    03              	INC	BC		; Next byte in string
21A3    C3 97 21        	JP	PRSLP		; More characters to output
21A6                    ;
21A6    B7              TESTR:	OR	A		; Test if enough room
21A7    0E              	DB	0EH		; No garbage collection done
21A8    F1              GRBDON: POP	AF		; Garbage collection done
21A9    F5              	PUSH	AF		; Save status
21AA    2A 9F C0        	LD	HL,(STRSPC)	; Bottom of string space in use
21AD    EB              	EX	DE,HL		; To DE
21AE    2A 08 C1        	LD	HL,(STRBOT)	; Bottom of string area
21B1    2F              	CPL			; Negate length (Top down)
21B2    4F              	LD	C,A		; -Length to BC
21B3    06 FF           	LD	B,-1		; BC = -ve length of string
21B5    09              	ADD	HL,BC		; Add to bottom of space in use
21B6    23              	INC	HL		; Plus one for 2's complement
21B7    CD B7 16        	CALL	CPDEHL		; Below string RAM area?
21BA    DA C4 21        	JP	C,TESTOS	; Tidy up if not done else err
21BD    22 08 C1        	LD	(STRBOT),HL	; Save new bottom of area
21C0    23              	INC	HL		; Point to first byte of string
21C1    EB              	EX	DE,HL		; Address to DE
21C2    F1              POPAF:	POP	AF		; Throw away status push
21C3    C9              	RET
21C4                    ;
21C4    F1              TESTOS: POP	AF		; Garbage collect been done?
21C5    1E 1A           	LD	E,OS		; ?OS Error
21C7    CA 03 14        	JP	Z,ERROR_	; Yes - Not enough string apace
21CA    BF              	CP	A		; Flag garbage collect done
21CB    F5              	PUSH	AF		; Save status
21CC    01 A8 21        	LD	BC,GRBDON	; Garbage collection done
21CF    C5              	PUSH	BC		; Save for RETurn
21D0    2A F4 C0        GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
21D3    22 08 C1        GARBLP: LD	(STRBOT),HL	; Reset string pointer
21D6    21 00 00        	LD	HL,0
21D9    E5              	PUSH	HL		; Flag no string found
21DA    2A 9F C0        	LD	HL,(STRSPC)	; Get bottom of string space
21DD    E5              	PUSH	HL		; Save bottom of string space
21DE    21 F8 C0        	LD	HL,TMSTPL	; Temporary string pool
21E1    EB              GRBLP:	EX	DE,HL
21E2    2A F6 C0        	LD	HL,(TMSTPT)	; Temporary string pool pointer
21E5    EB              	EX	DE,HL
21E6    CD B7 16        	CALL	CPDEHL		; Temporary string pool done?
21E9    01 E1 21        	LD	BC,GRBLP	; Loop until string pool done
21EC    C2 35 22        	JP	NZ,STPOOL	; No - See if in string area
21EF    2A 1B C1        	LD	HL,(PROGND)	; Start of simple variables
21F2    EB              SMPVAR: EX	DE,HL
21F3    2A 1D C1        	LD	HL,(VAREND)	; End of simple variables
21F6    EB              	EX	DE,HL
21F7    CD B7 16        	CALL	CPDEHL		; All simple strings done?
21FA    CA 08 22        	JP	Z,ARRLP		; Yes - Do string arrays
21FD    7E              	LD	A,(HL)		; Get type of variable
21FE    23              	INC	HL
21FF    23              	INC	HL
2200    B7              	OR	A		; "S" flag set if string
2201    CD 38 22        	CALL	STRADD		; See if string in string area
2204    C3 F2 21        	JP	SMPVAR		; Loop until simple ones done
2207                    ;
2207    C1              GNXARY: POP	BC		; Scrap address of this array
2208    EB              ARRLP:	EX	DE,HL
2209    2A 1F C1        	LD	HL,(ARREND)	; End of string arrays
220C    EB              	EX	DE,HL
220D    CD B7 16        	CALL	CPDEHL		; All string arrays done?
2210    CA 5E 22        	JP	Z,SCNEND	; Yes - Move string if found
2213    CD E5 26        	CALL	LOADFP		; Get array name to BCDE
2216    7B              	LD	A,E		; Get type of array
2217    E5              	PUSH	HL		; Save address of num of dim'ns
2218    09              	ADD	HL,BC		; Start of next array
2219    B7              	OR	A		; Test type of array
221A    F2 07 22        	JP	P,GNXARY	; Numeric array - Ignore it
221D    22 0A C1        	LD	(CUROPR),HL	; Save address of next array
2220    E1              	POP	HL		; Get address of num of dim'ns
2221    4E              	LD	C,(HL)		; BC = Number of dimensions
2222    06 00           	LD	B,0
2224    09              	ADD	HL,BC		; Two bytes per dimension size
2225    09              	ADD	HL,BC
2226    23              	INC	HL		; Plus one for number of dim'ns
2227    EB              GRBARY: EX	DE,HL
2228    2A 0A C1        	LD	HL,(CUROPR)	; Get address of next array
222B    EB              	EX	DE,HL
222C    CD B7 16        	CALL	CPDEHL		; Is this array finished?
222F    CA 08 22        	JP	Z,ARRLP		; Yes - Get next one
2232    01 27 22        	LD	BC,GRBARY	; Loop until array all done
2235    C5              STPOOL: PUSH	BC		; Save return address
2236    F6 80           	OR	80H		; Flag string type
2238    7E              STRADD: LD	A,(HL)		; Get string length
2239    23              	INC	HL
223A    23              	INC	HL
223B    5E              	LD	E,(HL)		; Get LSB of string address
223C    23              	INC	HL
223D    56              	LD	D,(HL)		; Get MSB of string address
223E    23              	INC	HL
223F    F0              	RET	P		; Not a string - Return
2240    B7              	OR	A		; Set flags on string length
2241    C8              	RET	Z		; Null string - Return
2242    44              	LD	B,H		; Save variable pointer
2243    4D              	LD	C,L
2244    2A 08 C1        	LD	HL,(STRBOT)	; Bottom of new area
2247    CD B7 16        	CALL	CPDEHL		; String been done?
224A    60              	LD	H,B		; Restore variable pointer
224B    69              	LD	L,C
224C    D8              	RET	C		; String done - Ignore
224D    E1              	POP	HL		; Return address
224E    E3              	EX	(SP),HL		; Lowest available string area
224F    CD B7 16        	CALL	CPDEHL		; String within string area?
2252    E3              	EX	(SP),HL		; Lowest available string area
2253    E5              	PUSH	HL		; Re-save return address
2254    60              	LD	H,B		; Restore variable pointer
2255    69              	LD	L,C
2256    D0              	RET	NC		; Outside string area - Ignore
2257    C1              	POP	BC		; Get return , Throw 2 away
2258    F1              	POP	AF		;
2259    F1              	POP	AF		;
225A    E5              	PUSH	HL		; Save variable pointer
225B    D5              	PUSH	DE		; Save address of current
225C    C5              	PUSH	BC		; Put back return address
225D    C9              	RET			; Go to it
225E                    ;
225E    D1              SCNEND: POP	DE		; Addresses of strings
225F    E1              	POP	HL		;
2260    7D              	LD	A,L		; HL = 0 if no more to do
2261    B4              	OR	H
2262    C8              	RET	Z		; No more to do - Return
2263    2B              	DEC	HL
2264    46              	LD	B,(HL)		; MSB of address of string
2265    2B              	DEC	HL
2266    4E              	LD	C,(HL)		; LSB of address of string
2267    E5              	PUSH	HL		; Save variable address
2268    2B              	DEC	HL
2269    2B              	DEC	HL
226A    6E              	LD	L,(HL)		; HL = Length of string
226B    26 00           	LD	H,0
226D    09              	ADD	HL,BC		; Address of end of string+1
226E    50              	LD	D,B		; String address to DE
226F    59              	LD	E,C
2270    2B              	DEC	HL		; Last byte in string
2271    44              	LD	B,H		; Address to BC
2272    4D              	LD	C,L
2273    2A 08 C1        	LD	HL,(STRBOT)	; Current bottom of string area
2276    CD BE 13        	CALL	MOVSTR		; Move string to new address
2279    E1              	POP	HL		; Restore variable address
227A    71              	LD	(HL),C		; Save new LSB of address
227B    23              	INC	HL
227C    70              	LD	(HL),B		; Save new MSB of address
227D    69              	LD	L,C		; Next string area+1 to HL
227E    60              	LD	H,B
227F    2B              	DEC	HL		; Next string area address
2280    C3 D3 21        	JP	GARBLP		; Look for more strings
2283                    ;
2283    C5              CONCAT: PUSH	BC		; Save prec' opr & code string
2284    E5              	PUSH	HL		;
2285    2A 29 C1        	LD	HL,(FPREG)	; Get first string
2288    E3              	EX	(SP),HL		; Save first string
2289    CD 3D 1D        	CALL	OPRND		; Get second string
228C    E3              	EX	(SP),HL		; Restore first string
228D    CD B8 1C        	CALL	TSTSTR		; Make sure it's a string
2290    7E              	LD	A,(HL)		; Get length of second string
2291    E5              	PUSH	HL		; Save first string
2292    2A 29 C1        	LD	HL,(FPREG)	; Get second string
2295    E5              	PUSH	HL		; Save second string
2296    86              	ADD	A,(HL)		; Add length of second string
2297    1E 1C           	LD	E,LS		; ?LS Error
2299    DA 03 14        	JP	C,ERROR_	; String too long - Error
229C    CD 3C 21        	CALL	MKTMST		; Make temporary string
229F    D1              	POP	DE		; Get second string to DE
22A0    CD D4 22        	CALL	GSTRDE		; Move to string pool if needed
22A3    E3              	EX	(SP),HL		; Get first string
22A4    CD D3 22        	CALL	GSTRHL		; Move to string pool if needed
22A7    E5              	PUSH	HL		; Save first string
22A8    2A 06 C1        	LD	HL,(TMPSTR+2)	; Temporary string address
22AB    EB              	EX	DE,HL		; To DE
22AC    CD BA 22        	CALL	SSTSA		; First string to string area
22AF    CD BA 22        	CALL	SSTSA		; Second string to string area
22B2    21 D2 1C        	LD	HL,EVAL2	; Return to evaluation loop
22B5    E3              	EX	(SP),HL		; Save return,get code string
22B6    E5              	PUSH	HL		; Save code string address
22B7    C3 6D 21        	JP	TSTOPL		; To temporary string to pool
22BA                    ;
22BA    E1              SSTSA:	POP	HL		; Return address
22BB    E3              	EX	(SP),HL		; Get string block,save return
22BC    7E              	LD	A,(HL)		; Get length of string
22BD    23              	INC	HL
22BE    23              	INC	HL
22BF    4E              	LD	C,(HL)		; Get LSB of string address
22C0    23              	INC	HL
22C1    46              	LD	B,(HL)		; Get MSB of string address
22C2    6F              	LD	L,A		; Length to L
22C3    2C              TOSTRA: INC	L		; INC - DECed after
22C4    2D              TSALP:	DEC	L		; Count bytes moved
22C5    C8              	RET	Z		; End of string - Return
22C6    0A              	LD	A,(BC)		; Get source
22C7    12              	LD	(DE),A		; Save destination
22C8    03              	INC	BC		; Next source
22C9    13              	INC	DE		; Next destination
22CA    C3 C4 22        	JP	TSALP		; Loop until string moved
22CD                    ;
22CD    CD B8 1C        GETSTR: CALL	TSTSTR		; Make sure it's a string
22D0    2A 29 C1        GSTRCU: LD	HL,(FPREG)	; Get current string
22D3    EB              GSTRHL: EX	DE,HL		; Save DE
22D4    CD EE 22        GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
22D7    EB              	EX	DE,HL		; Restore DE
22D8    C0              	RET	NZ		; No - Return
22D9    D5              	PUSH	DE		; Save string
22DA    50              	LD	D,B		; String block address to DE
22DB    59              	LD	E,C
22DC    1B              	DEC	DE		; Point to length
22DD    4E              	LD	C,(HL)		; Get string length
22DE    2A 08 C1        	LD	HL,(STRBOT)	; Current bottom of string area
22E1    CD B7 16        	CALL	CPDEHL		; Last one in string area?
22E4    C2 EC 22        	JP	NZ,POPHL	; No - Return
22E7    47              	LD	B,A		; Clear B (A=0)
22E8    09              	ADD	HL,BC		; Remove string from str' area
22E9    22 08 C1        	LD	(STRBOT),HL	; Save new bottom of str' area
22EC    E1              POPHL:	POP	HL		; Restore string
22ED    C9              	RET
22EE                    ;
22EE    2A F6 C0        BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
22F1    2B              	DEC	HL		; Back
22F2    46              	LD	B,(HL)		; Get MSB of address
22F3    2B              	DEC	HL		; Back
22F4    4E              	LD	C,(HL)		; Get LSB of address
22F5    2B              	DEC	HL		; Back
22F6    2B              	DEC	HL		; Back
22F7    CD B7 16        	CALL	CPDEHL		; String last in string pool?
22FA    C0              	RET	NZ		; Yes - Leave it
22FB    22 F6 C0        	LD	(TMSTPT),HL	; Save new string pool top
22FE    C9              	RET
22FF                    ;
22FF    01 7E 20        LEN:	LD	BC,PASSA	; To return integer A
2302    C5              	PUSH	BC		; Save address
2303    CD CD 22        GETLEN: CALL	GETSTR		; Get string and its length
2306    AF              	XOR	A
2307    57              	LD	D,A		; Clear D
2308    32 F2 C0        	LD	(TYPE),A	; Set type to numeric
230B    7E              	LD	A,(HL)		; Get length of string
230C    B7              	OR	A		; Set status flags
230D    C9              	RET
230E                    ;
230E    01 7E 20        ASC:	LD	BC,PASSA	; To return integer A
2311    C5              	PUSH	BC		; Save address
2312    CD 03 23        GTFLNM: CALL	GETLEN		; Get length of string
2315    CA 0E 19        	JP	Z,FCERR		; Null string - Error
2318    23              	INC	HL
2319    23              	INC	HL
231A    5E              	LD	E,(HL)		; Get LSB of address
231B    23              	INC	HL
231C    56              	LD	D,(HL)		; Get MSB of address
231D    1A              	LD	A,(DE)		; Get first byte of string
231E    C9              	RET
231F                    ;
231F    3E 01           CHR:	LD	A,1		; One character string
2321    CD 3C 21        	CALL	MKTMST		; Make a temporary string
2324    CD 18 24        	CALL	MAKINT		; Make it integer A
2327    2A 06 C1        	LD	HL,(TMPSTR+2)	; Get address of string
232A    73              	LD	(HL),E		; Save character
232B    C1              TOPOOL: POP	BC		; Clean up stack
232C    C3 6D 21        	JP	TSTOPL		; Temporary string to pool
232F                    ;
232F    CD C8 23        LEFT:	CALL	LFRGNM		; Get number and ending ")"
2332    AF              	XOR	A		; Start at first byte in string
2333    E3              RIGHT1: EX	(SP),HL		; Save code string,Get string
2334    4F              	LD	C,A		; Starting position in string
2335    E5              MID1:	PUSH	HL		; Save string block address
2336    7E              	LD	A,(HL)		; Get length of string
2337    B8              	CP	B		; Compare with number given
2338    DA 3D 23        	JP	C,ALLFOL	; All following bytes required
233B    78              	LD	A,B		; Get new length
233C    11              	DB	11H		; Skip "LD C,0"
233D    0E 00           ALLFOL: LD	C,0		; First byte of string
233F    C5              	PUSH	BC		; Save position in string
2340    CD A6 21        	CALL	TESTR		; See if enough string space
2343    C1              	POP	BC		; Get position in string
2344    E1              	POP	HL		; Restore string block address
2345    E5              	PUSH	HL		; And re-save it
2346    23              	INC	HL
2347    23              	INC	HL
2348    46              	LD	B,(HL)		; Get LSB of address
2349    23              	INC	HL
234A    66              	LD	H,(HL)		; Get MSB of address
234B    68              	LD	L,B		; HL = address of string
234C    06 00           	LD	B,0		; BC = starting address
234E    09              	ADD	HL,BC		; Point to that byte
234F    44              	LD	B,H		; BC = source string
2350    4D              	LD	C,L
2351    CD 3F 21        	CALL	CRTMST		; Create a string entry
2354    6F              	LD	L,A		; Length of new string
2355    CD C3 22        	CALL	TOSTRA		; Move string to string area
2358    D1              	POP	DE		; Clear stack
2359    CD D4 22        	CALL	GSTRDE		; Move to string pool if needed
235C    C3 6D 21        	JP	TSTOPL		; Temporary string to pool
235F                    ;
235F    CD C8 23        RIGHT:	CALL	LFRGNM		; Get number and ending ")"
2362    D1              	POP	DE		; Get string length
2363    D5              	PUSH	DE		; And re-save
2364    1A              	LD	A,(DE)		; Get length
2365    90              	SUB	B		; Move back N bytes
2366    C3 33 23        	JP	RIGHT1		; Go and get sub-string
2369                    ;
2369    EB              MID:	EX	DE,HL		; Get code string address
236A    7E              	LD	A,(HL)		; Get next byte ',' or ")"
236B    CD CD 23        	CALL	MIDNUM		; Get number supplied
236E    04              	INC	B		; Is it character zero?
236F    05              	DEC	B
2370    CA 0E 19        	JP	Z,FCERR		; Yes - Error
2373    C5              	PUSH	BC		; Save starting position
2374    1E FF           	LD	E,255		; All of string
2376    FE 29           	CP	')'		; Any length given?
2378    CA 82 23        	JP	Z,RSTSTR	; No - Rest of string
237B    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
237E    2C              	DB	','
237F    CD 15 24        	CALL	GETINT		; Get integer 0-255
2382    CD BD 16        RSTSTR: CALL	CHKSYN		; Make sure ")" follows
2385    29              	DB	")"
2386    F1              	POP	AF		; Restore starting position
2387    E3              	EX	(SP),HL		; Get string,8ave code string
2388    01 35 23        	LD	BC,MID1		; Continuation of MID$ routine
238B    C5              	PUSH	BC		; Save for return
238C    3D              	DEC	A		; Starting position-1
238D    BE              	CP	(HL)		; Compare with length
238E    06 00           	LD	B,0		; Zero bytes length
2390    D0              	RET	NC		; Null string if start past end
2391    4F              	LD	C,A		; Save starting position-1
2392    7E              	LD	A,(HL)		; Get length of string
2393    91              	SUB	C		; Subtract start
2394    BB              	CP	E		; Enough string for it?
2395    47              	LD	B,A		; Save maximum length available
2396    D8              	RET	C		; Truncate string if needed
2397    43              	LD	B,E		; Set specified length
2398    C9              	RET			; Go and create string
2399                    ;
2399    CD 03 23        VAL:	CALL	GETLEN		; Get length of string
239C    CA B6 24        	JP	Z,RESZER	; Result zero
239F    5F              	LD	E,A		; Save length
23A0    23              	INC	HL
23A1    23              	INC	HL
23A2    7E              	LD	A,(HL)		; Get LSB of address
23A3    23              	INC	HL
23A4    66              	LD	H,(HL)		; Get MSB of address
23A5    6F              	LD	L,A		; HL = String address
23A6    E5              	PUSH	HL		; Save string address
23A7    19              	ADD	HL,DE
23A8    46              	LD	B,(HL)		; Get end of string+1 byte
23A9    72              	LD	(HL),D		; Zero it to terminate
23AA    E3              	EX	(SP),HL		; Save string end,get start
23AB    C5              	PUSH	BC		; Save end+1 byte
23AC    7E              	LD	A,(HL)		; Get starting byte
23AD    FE 24           	CP	'$'		; Hex number indicated? [function added]
23AF    C2 B7 23        	JP	NZ,VAL1
23B2    CD E1 2B        	CALL	HEXTFP		; Convert Hex to FPREG
23B5    18 0D           	JR	VAL3
23B7    FE 25           VAL1:	CP	'%'		; Binary number indicated? [function added]
23B9    C2 C1 23        	JP	NZ,VAL2
23BC    CD 51 2C        	CALL	BINTFP		; Convert Bin to FPREG
23BF    18 03           	JR	VAL3
23C1    CD 9D 27        VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
23C4    C1              VAL3:	POP	BC		; Restore end+1 byte
23C5    E1              	POP	HL		; Restore end+1 address
23C6    70              	LD	(HL),B		; Put back original byte
23C7    C9              	RET
23C8                    ;
23C8    EB              LFRGNM: EX	DE,HL		; Code string address to HL
23C9    CD BD 16        	CALL	CHKSYN		; Make sure ")" follows
23CC    29              	DB	")"
23CD    C1              MIDNUM: POP	BC		; Get return address
23CE    D1              	POP	DE		; Get number supplied
23CF    C5              	PUSH	BC		; Re-save return address
23D0    43              	LD	B,E		; Number to B
23D1    C9              	RET
23D2                    ;
23D2    CD 18 24        INP:	CALL	MAKINT		; Make it integer A
23D5    32 84 C0        	LD	(INPORT),A	; Set input port
23D8    CD 83 C0        	CALL	INPSUB		; Get input from port
23DB    C3 7E 20        	JP	PASSA		; Return integer A
23DE                    ;
23DE    CD 02 24        POUT:	CALL	SETIO		; Set up port number
23E1    C3 4B C0        	JP	OUTSUB		; Output data and return
23E4                    ;
23E4    CD 02 24        WAIT:	CALL	SETIO		; Set up port number
23E7    F5              	PUSH	AF		; Save AND mask
23E8    1E 00           	LD	E,0		; Assume zero if none given
23EA    2B              	DEC	HL		; DEC 'cos GETCHR INCs
23EB    CD 47 18        	CALL	GETCHR		; Get next character
23EE    CA F8 23        	JP	Z,NOXOR		; No XOR byte given
23F1    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
23F4    2C              	DB	','
23F5    CD 15 24        	CALL	GETINT		; Get integer 0-255 to XOR with
23F8    C1              NOXOR:	POP	BC		; Restore AND mask
23F9    CD 83 C0        WAITLP: CALL	INPSUB		; Get input
23FC    AB              	XOR	E		; Flip selected bits
23FD    A0              	AND	B		; Result non-zero?
23FE    CA F9 23        	JP	Z,WAITLP	; No = keep waiting
2401    C9              	RET
2402                    ;
2402    CD 15 24        SETIO:	CALL	GETINT		; Get integer 0-255
2405    32 84 C0        	LD	(INPORT),A	; Set input port
2408    32 4C C0        	LD	(OTPORT),A	; Set output port
240B    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
240E    2C              	DB	','
240F    C3 15 24        	JP	GETINT		; Get integer 0-255 and return
2412                    ;
2412    CD 47 18        FNDNUM: CALL	GETCHR		; Get next character
2415    CD B4 1C        GETINT: CALL	GETNUM		; Get a number from 0 to 255
2418    CD F3 18        MAKINT: CALL	DEPINT		; Make sure value 0 - 255
241B    7A              	LD	A,D		; Get MSB of number
241C    B7              	OR	A		; Zero?
241D    C2 0E 19        	JP	NZ,FCERR	; No - Error
2420    2B              	DEC	HL		; DEC 'cos GETCHR INCs
2421    CD 47 18        	CALL	GETCHR		; Get next character
2424    7B              	LD	A,E		; Get number to A
2425    C9              	RET
2426                    ;
2426    CD F9 18        PEEK:	CALL	DEINT		; Get memory address
2429    1A              	LD	A,(DE)		; Get byte in memory
242A    C3 7E 20        	JP	PASSA		; Return integer A
242D                    ;
242D    CD B4 1C        POKE:	CALL	GETNUM		; Get memory address
2430    CD F9 18        	CALL	DEINT		; Get integer -32768 to 3276
2433    D5              	PUSH	DE		; Save memory address
2434    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
2437    2C              	DB	','
2438    CD 15 24        	CALL	GETINT		; Get integer 0-255
243B    D1              	POP	DE		; Restore memory address
243C    12              	LD	(DE),A		; Load it into memory
243D    C9              	RET
243E                    ;
243E    21 14 29        ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
2441    CD E5 26        ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
2444    C3 50 24        	JP	FPADD		; Add BCDE to FPREG
2447                    ;
2447    CD E5 26        SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
244A    21              	DB	21H		; Skip "POP BC" and "POP DE"
244B    C1              PSUB:	POP	BC		; Get FP number from stack
244C    D1              	POP	DE
244D    CD BF 26        SUBCDE: CALL	INVSGN		; Negate FPREG
2450    78              FPADD:	LD	A,B		; Get FP exponent
2451    B7              	OR	A		; Is number zero?
2452    C8              	RET	Z		; Yes - Nothing to add
2453    3A 2C C1        	LD	A,(FPEXP)	; Get FPREG exponent
2456    B7              	OR	A		; Is this number zero?
2457    CA D7 26        	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
245A    90              	SUB	B		; BCDE number larger?
245B    D2 6A 24        	JP	NC,NOSWAP	; No - Don't swap them
245E    2F              	CPL			; Two's complement
245F    3C              	INC	A		;	FP exponent
2460    EB              	EX	DE,HL
2461    CD C7 26        	CALL	STAKFP		; Put FPREG on stack
2464    EB              	EX	DE,HL
2465    CD D7 26        	CALL	FPBCDE		; Move BCDE to FPREG
2468    C1              	POP	BC		; Restore number from stack
2469    D1              	POP	DE
246A    FE 19           NOSWAP: CP	24+1		; Second number insignificant?
246C    D0              	RET	NC		; Yes - First number is result
246D    F5              	PUSH	AF		; Save number of bits to scale
246E    CD FC 26        	CALL	SIGNS		; Set MSBs & sign of result
2471    67              	LD	H,A		; Save sign of result
2472    F1              	POP	AF		; Restore scaling factor
2473    CD 15 25        	CALL	SCALE		; Scale BCDE to same exponent
2476    B4              	OR	H		; Result to be positive?
2477    21 29 C1        	LD	HL,FPREG	; Point to FPREG
247A    F2 90 24        	JP	P,MINCDE	; No - Subtract FPREG from CDE
247D    CD F5 24        	CALL	PLUCDE		; Add FPREG to CDE
2480    D2 D6 24        	JP	NC,RONDUP	; No overflow - Round it up
2483    23              	INC	HL		; Point to exponent
2484    34              	INC	(HL)		; Increment it
2485    CA FE 13        	JP	Z,OVERR		; Number overflowed - Error
2488    2E 01           	LD	L,1		; 1 bit to shift right
248A    CD 2B 25        	CALL	SHRT1		; Shift result right
248D    C3 D6 24        	JP	RONDUP		; Round it up
2490                    ;
2490    AF              MINCDE: XOR	A		; Clear A and carry
2491    90              	SUB	B		; Negate exponent
2492    47              	LD	B,A		; Re-save exponent
2493    7E              	LD	A,(HL)		; Get LSB of FPREG
2494    9B              	SBC	A, E		; Subtract LSB of BCDE
2495    5F              	LD	E,A		; Save LSB of BCDE
2496    23              	INC	HL
2497    7E              	LD	A,(HL)		; Get NMSB of FPREG
2498    9A              	SBC	A,D		; Subtract NMSB of BCDE
2499    57              	LD	D,A		; Save NMSB of BCDE
249A    23              	INC	HL
249B    7E              	LD	A,(HL)		; Get MSB of FPREG
249C    99              	SBC	A,C		; Subtract MSB of BCDE
249D    4F              	LD	C,A		; Save MSB of BCDE
249E    DC 01 25        CONPOS: CALL	C,COMPL		; Overflow - Make it positive
24A1                    ;
24A1    68              BNORM:	LD	L,B		; L = Exponent
24A2    63              	LD	H,E		; H = LSB
24A3    AF              	XOR	A
24A4    47              BNRMLP: LD	B,A		; Save bit count
24A5    79              	LD	A,C		; Get MSB
24A6    B7              	OR	A		; Is it zero?
24A7    C2 C3 24        	JP	NZ,PNORM	; No - Do it bit at a time
24AA    4A              	LD	C,D		; MSB = NMSB
24AB    54              	LD	D,H		; NMSB= LSB
24AC    65              	LD	H,L		; LSB = VLSB
24AD    6F              	LD	L,A		; VLSB= 0
24AE    78              	LD	A,B		; Get exponent
24AF    D6 08           	SUB	8		; Count 8 bits
24B1    FE E0           	CP	0E0H		; -24-8 Was number zero?
24B3    C2 A4 24        	JP	NZ,BNRMLP	; No - Keep normalising
24B6    AF              RESZER: XOR	A		; Result is zero
24B7    32 2C C1        SAVEXP: LD	(FPEXP),A	; Save result as zero
24BA    C9              	RET
24BB                    ;
24BB    05              NORMAL: DEC	B		; Count bits
24BC    29              	ADD	HL,HL		; Shift HL left
24BD    7A              	LD	A,D		; Get NMSB
24BE    17              	RLA			; Shift left with last bit
24BF    57              	LD	D,A		; Save NMSB
24C0    79              	LD	A,C		; Get MSB
24C1    8F              	ADC	A,A		; Shift left with last bit
24C2    4F              	LD	C,A		; Save MSB
24C3    F2 BB 24        PNORM:	JP	P,NORMAL	; Not done - Keep going
24C6    78              	LD	A,B		; Number of bits shifted
24C7    5C              	LD	E,H		; Save HL in EB
24C8    45              	LD	B,L
24C9    B7              	OR	A		; Any shifting done?
24CA    CA D6 24        	JP	Z,RONDUP	; No - Round it up
24CD    21 2C C1        	LD	HL,FPEXP	; Point to exponent
24D0    86              	ADD	A,(HL)		; Add shifted bits
24D1    77              	LD	(HL),A		; Re-save exponent
24D2    D2 B6 24        	JP	NC,RESZER	; Underflow - Result is zero
24D5    C8              	RET	Z		; Result is zero
24D6    78              RONDUP: LD	A,B		; Get VLSB of number
24D7    21 2C C1        RONDB:	LD	HL,FPEXP	; Point to exponent
24DA    B7              	OR	A		; Any rounding?
24DB    FC E8 24        	CALL	M,FPROND	; Yes - Round number up
24DE    46              	LD	B,(HL)		; B = Exponent
24DF    23              	INC	HL
24E0    7E              	LD	A,(HL)		; Get sign of result
24E1    E6 80           	AND	10000000B	; Only bit 7 needed
24E3    A9              	XOR	C		; Set correct sign
24E4    4F              	LD	C,A		; Save correct sign in number
24E5    C3 D7 26        	JP	FPBCDE		; Move BCDE to FPREG
24E8                    ;
24E8    1C              FPROND: INC	E		; Round LSB
24E9    C0              	RET	NZ		; Return if ok
24EA    14              	INC	D		; Round NMSB
24EB    C0              	RET	NZ		; Return if ok
24EC    0C              	INC	C		; Round MSB
24ED    C0              	RET	NZ		; Return if ok
24EE    0E 80           	LD	C,80H		; Set normal value
24F0    34              	INC	(HL)		; Increment exponent
24F1    C0              	RET	NZ		; Return if ok
24F2    C3 FE 13        	JP	OVERR		; Overflow error
24F5                    ;
24F5    7E              PLUCDE: LD	A,(HL)		; Get LSB of FPREG
24F6    83              	ADD	A,E		; Add LSB of BCDE
24F7    5F              	LD	E,A		; Save LSB of BCDE
24F8    23              	INC	HL
24F9    7E              	LD	A,(HL)		; Get NMSB of FPREG
24FA    8A              	ADC	A,D		; Add NMSB of BCDE
24FB    57              	LD	D,A		; Save NMSB of BCDE
24FC    23              	INC	HL
24FD    7E              	LD	A,(HL)		; Get MSB of FPREG
24FE    89              	ADC	A,C		; Add MSB of BCDE
24FF    4F              	LD	C,A		; Save MSB of BCDE
2500    C9              	RET
2501                    ;
2501    21 2D C1        COMPL:	LD	HL,SGNRES	; Sign of result
2504    7E              	LD	A,(HL)		; Get sign of result
2505    2F              	CPL			; Negate it
2506    77              	LD	(HL),A		; Put it back
2507    AF              	XOR	A
2508    6F              	LD	L,A		; Set L to zero
2509    90              	SUB	B		; Negate exponent,set carry
250A    47              	LD	B,A		; Re-save exponent
250B    7D              	LD	A,L		; Load zero
250C    9B              	SBC	A,E		; Negate LSB
250D    5F              	LD	E,A		; Re-save LSB
250E    7D              	LD	A,L		; Load zero
250F    9A              	SBC	A,D		; Negate NMSB
2510    57              	LD	D,A		; Re-save NMSB
2511    7D              	LD	A,L		; Load zero
2512    99              	SBC	A,C		; Negate MSB
2513    4F              	LD	C,A		; Re-save MSB
2514    C9              	RET
2515                    ;
2515    06 00           SCALE:	LD	B,0		; Clear underflow
2517    D6 08           SCALLP: SUB	8		; 8 bits (a whole byte)?
2519    DA 24 25        	JP	C,SHRITE	; No - Shift right A bits
251C    43              	LD	B,E		; <- Shift
251D    5A              	LD	E,D		; <- right
251E    51              	LD	D,C		; <- eight
251F    0E 00           	LD	C,0		; <- bits
2521    C3 17 25        	JP	SCALLP		; More bits to shift
2524                    ;
2524    C6 09           SHRITE: ADD	A,8+1		; Adjust count
2526    6F              	LD	L,A		; Save bits to shift
2527    AF              SHRLP:	XOR	A		; Flag for all done
2528    2D              	DEC	L		; All shifting done?
2529    C8              	RET	Z		; Yes - Return
252A    79              	LD	A,C		; Get MSB
252B    1F              SHRT1:	RRA			; Shift it right
252C    4F              	LD	C,A		; Re-save
252D    7A              	LD	A,D		; Get NMSB
252E    1F              	RRA			; Shift right with last bit
252F    57              	LD	D,A		; Re-save it
2530    7B              	LD	A,E		; Get LSB
2531    1F              	RRA			; Shift right with last bit
2532    5F              	LD	E,A		; Re-save it
2533    78              	LD	A,B		; Get underflow
2534    1F              	RRA			; Shift right with last bit
2535    47              	LD	B,A		; Re-save underflow
2536    C3 27 25        	JP	SHRLP		; More bits to do
2539                    ;
2539    00 00 00 81     UNITY:	DB	 000H,000H,000H,081H	; 1.00000
253D                    ;
253D    03              LOGTAB: DB	3			; Table used by LOG
253E    AA 56 19 80     	DB	0AAH,056H,019H,080H	; 0.59898
2542    F1 22 76 80     	DB	0F1H,022H,076H,080H	; 0.96147
2546    45 AA 38 82     	DB	045H,0AAH,038H,082H	; 2.88539
254A                    ;
254A    CD 96 26        LOG:	CALL	TSTSGN		; Test sign of value
254D    B7              	OR	A
254E    EA 0E 19        	JP	PE,FCERR	; ?FC Error if <= zero
2551    21 2C C1        	LD	HL,FPEXP	; Point to exponent
2554    7E              	LD	A,(HL)		; Get exponent
2555    01 35 80        	LD	BC,8035H	; BCDE = SQR(1/2)
2558    11 F3 04        	LD	DE,04F3H
255B    90              	SUB	B		; Scale value to be < 1
255C    F5              	PUSH	AF		; Save scale factor
255D    70              	LD	(HL),B		; Save new exponent
255E    D5              	PUSH	DE		; Save SQR(1/2)
255F    C5              	PUSH	BC
2560    CD 50 24        	CALL	FPADD		; Add SQR(1/2) to value
2563    C1              	POP	BC		; Restore SQR(1/2)
2564    D1              	POP	DE
2565    04              	INC	B		; Make it SQR(2)
2566    CD EC 25        	CALL	DVBCDE		; Divide by SQR(2)
2569    21 39 25        	LD	HL,UNITY	; Point to 1.
256C    CD 47 24        	CALL	SUBPHL		; Subtract FPREG from 1
256F    21 3D 25        	LD	HL,LOGTAB	; Coefficient table
2572    CD DE 29        	CALL	SUMSER		; Evaluate sum of series
2575    01 80 80        	LD	BC,8080H	; BCDE = -0.5
2578    11 00 00        	LD	DE,0000H
257B    CD 50 24        	CALL	FPADD		; Subtract 0.5 from FPREG
257E    F1              	POP	AF		; Restore scale factor
257F    CD 11 28        	CALL	RSCALE		; Re-scale number
2582    01 31 80        MULLN2: LD	BC,8031H	; BCDE = Ln(2)
2585    11 18 72        	LD	DE,7218H
2588    21              	DB	21H		; Skip "POP BC" and "POP DE"
2589                    ;
2589    C1              MULT:	POP	BC		; Get number from stack
258A    D1              	POP	DE
258B    CD 96 26        FPMULT: CALL	TSTSGN		; Test sign of FPREG
258E    C8              	RET	Z		; Return zero if zero
258F    2E 00           	LD	L,0		; Flag add exponents
2591    CD 54 26        	CALL	ADDEXP		; Add exponents
2594    79              	LD	A,C		; Get MSB of multiplier
2595    32 3B C1        	LD	(MULVAL),A	; Save MSB of multiplier
2598    EB              	EX	DE,HL
2599    22 3C C1        	LD	(MULVAL+1),HL	; Save rest of multiplier
259C    01 00 00        	LD	BC,0		; Partial product (BCDE) = zero
259F    50              	LD	D,B
25A0    58              	LD	E,B
25A1    21 A1 24        	LD	HL,BNORM	; Address of normalise
25A4    E5              	PUSH	HL		; Save for return
25A5    21 AD 25        	LD	HL,MULT8	; Address of 8 bit multiply
25A8    E5              	PUSH	HL		; Save for NMSB,MSB
25A9    E5              	PUSH	HL		;
25AA    21 29 C1        	LD	HL,FPREG	; Point to number
25AD    7E              MULT8:	LD	A,(HL)		; Get LSB of number
25AE    23              	INC	HL		; Point to NMSB
25AF    B7              	OR	A		; Test LSB
25B0    CA D9 25        	JP	Z,BYTSFT	; Zero - shift to next byte
25B3    E5              	PUSH	HL		; Save address of number
25B4    2E 08           	LD	L,8		; 8 bits to multiply by
25B6    1F              MUL8LP: RRA			; Shift LSB right
25B7    67              	LD	H,A		; Save LSB
25B8    79              	LD	A,C		; Get MSB
25B9    D2 C7 25        	JP	NC,NOMADD	; Bit was zero - Don't add
25BC    E5              	PUSH	HL		; Save LSB and count
25BD    2A 3C C1        	LD	HL,(MULVAL+1)	; Get LSB and NMSB
25C0    19              	ADD	HL,DE		; Add NMSB and LSB
25C1    EB              	EX	DE,HL		; Leave sum in DE
25C2    E1              	POP	HL		; Restore MSB and count
25C3    3A 3B C1        	LD	A,(MULVAL)	; Get MSB of multiplier
25C6    89              	ADC	A,C		; Add MSB
25C7    1F              NOMADD: RRA			; Shift MSB right
25C8    4F              	LD	C,A		; Re-save MSB
25C9    7A              	LD	A,D		; Get NMSB
25CA    1F              	RRA			; Shift NMSB right
25CB    57              	LD	D,A		; Re-save NMSB
25CC    7B              	LD	A,E		; Get LSB
25CD    1F              	RRA			; Shift LSB right
25CE    5F              	LD	E,A		; Re-save LSB
25CF    78              	LD	A,B		; Get VLSB
25D0    1F              	RRA			; Shift VLSB right
25D1    47              	LD	B,A		; Re-save VLSB
25D2    2D              	DEC	L		; Count bits multiplied
25D3    7C              	LD	A,H		; Get LSB of multiplier
25D4    C2 B6 25        	JP	NZ,MUL8LP	; More - Do it
25D7    E1              POPHRT: POP	HL		; Restore address of number
25D8    C9              	RET
25D9                    ;
25D9    43              BYTSFT: LD	B,E		; Shift partial product left
25DA    5A              	LD	E,D
25DB    51              	LD	D,C
25DC    4F              	LD	C,A
25DD    C9              	RET
25DE                    ;
25DE    CD C7 26        DIV10:	CALL	STAKFP		; Save FPREG on stack
25E1    01 20 84        	LD	BC,8420H	; BCDE = 10.
25E4    11 00 00        	LD	DE,0000H
25E7    CD D7 26        	CALL	FPBCDE		; Move 10 to FPREG
25EA                    ;
25EA    C1              DIV:	POP	BC		; Get number from stack
25EB    D1              	POP	DE
25EC    CD 96 26        DVBCDE: CALL	TSTSGN		; Test sign of FPREG
25EF    CA F2 13        	JP	Z,DZERR		; Error if division by zero
25F2    2E FF           	LD	L,-1		; Flag subtract exponents
25F4    CD 54 26        	CALL	ADDEXP		; Subtract exponents
25F7    34              	INC	(HL)		; Add 2 to exponent to adjust
25F8    34              	INC	(HL)
25F9    2B              	DEC	HL		; Point to MSB
25FA    7E              	LD	A,(HL)		; Get MSB of dividend
25FB    32 57 C0        	LD	(DIV3),A	; Save for subtraction
25FE    2B              	DEC	HL
25FF    7E              	LD	A,(HL)		; Get NMSB of dividend
2600    32 53 C0        	LD	(DIV2),A	; Save for subtraction
2603    2B              	DEC	HL
2604    7E              	LD	A,(HL)		; Get MSB of dividend
2605    32 4F C0        	LD	(DIV1),A	; Save for subtraction
2608    41              	LD	B,C		; Get MSB
2609    EB              	EX	DE,HL		; NMSB,LSB to HL
260A    AF              	XOR	A
260B    4F              	LD	C,A		; Clear MSB of quotient
260C    57              	LD	D,A		; Clear NMSB of quotient
260D    5F              	LD	E,A		; Clear LSB of quotient
260E    32 5A C0        	LD	(DIV4),A	; Clear overflow count
2611    E5              DIVLP:	PUSH	HL		; Save divisor
2612    C5              	PUSH	BC
2613    7D              	LD	A,L		; Get LSB of number
2614    CD 4E C0        	CALL	DIVSUP		; Subt' divisor from dividend
2617    DE 00           	SBC	A,0		; Count for overflows
2619    3F              	CCF
261A    D2 24 26        	JP	NC,RESDIV	; Restore divisor if borrow
261D    32 5A C0        	LD	(DIV4),A	; Re-save overflow count
2620    F1              	POP	AF		; Scrap divisor
2621    F1              	POP	AF
2622    37              	SCF			; Set carry to
2623    D2              	DB	0D2H		; Skip "POP BC" and "POP HL"
2624                    ;
2624    C1              RESDIV: POP	BC		; Restore divisor
2625    E1              	POP	HL
2626    79              	LD	A,C		; Get MSB of quotient
2627    3C              	INC	A
2628    3D              	DEC	A
2629    1F              	RRA			; Bit 0 to bit 7
262A    FA D7 24        	JP	M,RONDB		; Done - Normalise result
262D    17              	RLA			; Restore carry
262E    7B              	LD	A,E		; Get LSB of quotient
262F    17              	RLA			; Double it
2630    5F              	LD	E,A		; Put it back
2631    7A              	LD	A,D		; Get NMSB of quotient
2632    17              	RLA			; Double it
2633    57              	LD	D,A		; Put it back
2634    79              	LD	A,C		; Get MSB of quotient
2635    17              	RLA			; Double it
2636    4F              	LD	C,A		; Put it back
2637    29              	ADD	HL,HL		; Double NMSB,LSB of divisor
2638    78              	LD	A,B		; Get MSB of divisor
2639    17              	RLA			; Double it
263A    47              	LD	B,A		; Put it back
263B    3A 5A C0        	LD	A,(DIV4)	; Get VLSB of quotient
263E    17              	RLA			; Double it
263F    32 5A C0        	LD	(DIV4),A	; Put it back
2642    79              	LD	A,C		; Get MSB of quotient
2643    B2              	OR	D		; Merge NMSB
2644    B3              	OR	E		; Merge LSB
2645    C2 11 26        	JP	NZ,DIVLP	; Not done - Keep dividing
2648    E5              	PUSH	HL		; Save divisor
2649    21 2C C1        	LD	HL,FPEXP	; Point to exponent
264C    35              	DEC	(HL)		; Divide by 2
264D    E1              	POP	HL		; Restore divisor
264E    C2 11 26        	JP	NZ,DIVLP	; Ok - Keep going
2651    C3 FE 13        	JP	OVERR		; Overflow error
2654                    ;
2654    78              ADDEXP: LD	A,B		; Get exponent of dividend
2655    B7              	OR	A		; Test it
2656    CA 78 26        	JP	Z,OVTST3	; Zero - Result zero
2659    7D              	LD	A,L		; Get add/subtract flag
265A    21 2C C1        	LD	HL,FPEXP	; Point to exponent
265D    AE              	XOR	(HL)		; Add or subtract it
265E    80              	ADD	A,B		; Add the other exponent
265F    47              	LD	B,A		; Save new exponent
2660    1F              	RRA			; Test exponent for overflow
2661    A8              	XOR	B
2662    78              	LD	A,B		; Get exponent
2663    F2 77 26        	JP	P,OVTST2	; Positive - Test for overflow
2666    C6 80           	ADD	A,80H		; Add excess 128
2668    77              	LD	(HL),A		; Save new exponent
2669    CA D7 25        	JP	Z,POPHRT	; Zero - Result zero
266C    CD FC 26        	CALL	SIGNS		; Set MSBs and sign of result
266F    77              	LD	(HL),A		; Save new exponent
2670    2B              	DEC	HL		; Point to MSB
2671    C9              	RET
2672                    ;
2672    CD 96 26        OVTST1: CALL	TSTSGN		; Test sign of FPREG
2675    2F              	CPL			; Invert sign
2676    E1              	POP	HL		; Clean up stack
2677    B7              OVTST2: OR	A		; Test if new exponent zero
2678    E1              OVTST3: POP	HL		; Clear off return address
2679    F2 B6 24        	JP	P,RESZER	; Result zero
267C    C3 FE 13        	JP	OVERR		; Overflow error
267F                    ;
267F    CD E2 26        MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
2682    78              	LD	A,B		; Get exponent
2683    B7              	OR	A		; Is it zero?
2684    C8              	RET	Z		; Yes - Result is zero
2685    C6 02           	ADD	A,2		; Multiply by 4
2687    DA FE 13        	JP	C,OVERR		; Overflow - ?OV Error
268A    47              	LD	B,A		; Re-save exponent
268B    CD 50 24        	CALL	FPADD		; Add BCDE to FPREG (Times 5)
268E    21 2C C1        	LD	HL,FPEXP	; Point to exponent
2691    34              	INC	(HL)		; Double number (Times 10)
2692    C0              	RET	NZ		; Ok - Return
2693    C3 FE 13        	JP	OVERR		; Overflow error
2696                    ;
2696    3A 2C C1        TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
2699    B7              	OR	A
269A    C8              	RET	Z		; RETurn if number is zero
269B    3A 2B C1        	LD	A,(FPREG+2)	; Get MSB of FPREG
269E    FE              	DB	0FEH		; Test sign
269F    2F              RETREL: CPL			; Invert sign
26A0    17              	RLA			; Sign bit to carry
26A1    9F              FLGDIF: SBC	A,A		; Carry to all bits of A
26A2    C0              	RET	NZ		; Return -1 if negative
26A3    3C              	INC	A		; Bump to +1
26A4    C9              	RET			; Positive - Return +1
26A5                    ;
26A5    CD 96 26        SGN:	CALL	TSTSGN		; Test sign of FPREG
26A8    06 88           FLGREL: LD	B,80H+8		; 8 bit integer in exponent
26AA    11 00 00        	LD	DE,0		; Zero NMSB and LSB
26AD    21 2C C1        RETINT: LD	HL,FPEXP	; Point to exponent
26B0    4F              	LD	C,A		; CDE = MSB,NMSB and LSB
26B1    70              	LD	(HL),B		; Save exponent
26B2    06 00           	LD	B,0		; CDE = integer to normalise
26B4    23              	INC	HL		; Point to sign of result
26B5    36 80           	LD	(HL),80H	; Set sign of result
26B7    17              	RLA			; Carry = sign of integer
26B8    C3 9E 24        	JP	CONPOS		; Set sign of result
26BB                    ;
26BB    CD 96 26        ABS:	CALL	TSTSGN		; Test sign of FPREG
26BE    F0              	RET	P		; Return if positive
26BF    21 2B C1        INVSGN: LD	HL,FPREG+2	; Point to MSB
26C2    7E              	LD	A,(HL)		; Get sign of mantissa
26C3    EE 80           	XOR	80H		; Invert sign of mantissa
26C5    77              	LD	(HL),A		; Re-save sign of mantissa
26C6    C9              	RET
26C7                    ;
26C7    EB              STAKFP: EX	DE,HL		; Save code string address
26C8    2A 29 C1        	LD	HL,(FPREG)	; LSB,NLSB of FPREG
26CB    E3              	EX	(SP),HL		; Stack them,get return
26CC    E5              	PUSH	HL		; Re-save return
26CD    2A 2B C1        	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
26D0    E3              	EX	(SP),HL		; Stack them,get return
26D1    E5              	PUSH	HL		; Re-save return
26D2    EB              	EX	DE,HL		; Restore code string address
26D3    C9              	RET
26D4                    ;
26D4    CD E5 26        PHLTFP: CALL	LOADFP		; Number at HL to BCDE
26D7    EB              FPBCDE: EX	DE,HL		; Save code string address
26D8    22 29 C1        	LD	(FPREG),HL	; Save LSB,NLSB of number
26DB    60              	LD	H,B		; Exponent of number
26DC    69              	LD	L,C		; MSB of number
26DD    22 2B C1        	LD	(FPREG+2),HL	; Save MSB and exponent
26E0    EB              	EX	DE,HL		; Restore code string address
26E1    C9              	RET
26E2                    ;
26E2    21 29 C1        BCDEFP: LD	HL,FPREG	; Point to FPREG
26E5    5E              LOADFP: LD	E,(HL)		; Get LSB of number
26E6    23              	INC	HL
26E7    56              	LD	D,(HL)		; Get NMSB of number
26E8    23              	INC	HL
26E9    4E              	LD	C,(HL)		; Get MSB of number
26EA    23              	INC	HL
26EB    46              	LD	B,(HL)		; Get exponent of number
26EC    23              INCHL:	INC	HL		; Used for conditional "INC HL"
26ED    C9              	RET
26EE                    ;
26EE    11 29 C1        FPTHL:	LD	DE,FPREG	; Point to FPREG
26F1    06 04           DETHL4: LD	B,4		; 4 bytes to move
26F3    1A              DETHLB: LD	A,(DE)		; Get source
26F4    77              	LD	(HL),A		; Save destination
26F5    13              	INC	DE		; Next source
26F6    23              	INC	HL		; Next destination
26F7    05              	DEC	B		; Count bytes
26F8    C2 F3 26        	JP	NZ,DETHLB	; Loop if more
26FB    C9              	RET
26FC                    ;
26FC    21 2B C1        SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
26FF    7E              	LD	A,(HL)		; Get MSB
2700    07              	RLCA			; Old sign to carry
2701    37              	SCF			; Set MSBit
2702    1F              	RRA			; Set MSBit of MSB
2703    77              	LD	(HL),A		; Save new MSB
2704    3F              	CCF			; Complement sign
2705    1F              	RRA			; Old sign to carry
2706    23              	INC	HL
2707    23              	INC	HL
2708    77              	LD	(HL),A		; Set sign of result
2709    79              	LD	A,C		; Get MSB
270A    07              	RLCA			; Old sign to carry
270B    37              	SCF			; Set MSBit
270C    1F              	RRA			; Set MSBit of MSB
270D    4F              	LD	C,A		; Save MSB
270E    1F              	RRA
270F    AE              	XOR	(HL)		; New sign of result
2710    C9              	RET
2711                    ;
2711    78              CMPNUM: LD	A,B		; Get exponent of number
2712    B7              	OR	A
2713    CA 96 26        	JP	Z,TSTSGN	; Zero - Test sign of FPREG
2716    21 9F 26        	LD	HL,RETREL	; Return relation routine
2719    E5              	PUSH	HL		; Save for return
271A    CD 96 26        	CALL	TSTSGN		; Test sign of FPREG
271D    79              	LD	A,C		; Get MSB of number
271E    C8              	RET	Z		; FPREG zero - Number's MSB
271F    21 2B C1        	LD	HL,FPREG+2	; MSB of FPREG
2722    AE              	XOR	(HL)		; Combine signs
2723    79              	LD	A,C		; Get MSB of number
2724    F8              	RET	M		; Exit if signs different
2725    CD 2B 27        	CALL	CMPFP		; Compare FP numbers
2728    1F              	RRA			; Get carry to sign
2729    A9              	XOR	C		; Combine with MSB of number
272A    C9              	RET
272B                    ;
272B    23              CMPFP:	INC	HL		; Point to exponent
272C    78              	LD	A,B		; Get exponent
272D    BE              	CP	(HL)		; Compare exponents
272E    C0              	RET	NZ		; Different
272F    2B              	DEC	HL		; Point to MBS
2730    79              	LD	A,C		; Get MSB
2731    BE              	CP	(HL)		; Compare MSBs
2732    C0              	RET	NZ		; Different
2733    2B              	DEC	HL		; Point to NMSB
2734    7A              	LD	A,D		; Get NMSB
2735    BE              	CP	(HL)		; Compare NMSBs
2736    C0              	RET	NZ		; Different
2737    2B              	DEC	HL		; Point to LSB
2738    7B              	LD	A,E		; Get LSB
2739    96              	SUB	(HL)		; Compare LSBs
273A    C0              	RET	NZ		; Different
273B    E1              	POP	HL		; Drop RETurn
273C    E1              	POP	HL		; Drop another RETurn
273D    C9              	RET
273E                    ;
273E    47              FPINT:	LD	B,A		; <- Move
273F    4F              	LD	C,A		; <- exponent
2740    57              	LD	D,A		; <- to all
2741    5F              	LD	E,A		; <- bits
2742    B7              	OR	A		; Test exponent
2743    C8              	RET	Z		; Zero - Return zero
2744    E5              	PUSH	HL		; Save pointer to number
2745    CD E2 26        	CALL	BCDEFP		; Move FPREG to BCDE
2748    CD FC 26        	CALL	SIGNS		; Set MSBs & sign of result
274B    AE              	XOR	(HL)		; Combine with sign of FPREG
274C    67              	LD	H,A		; Save combined signs
274D    FC 62 27        	CALL	M,DCBCDE	; Negative - Decrement BCDE
2750    3E 98           	LD	A,80H+24	; 24 bits
2752    90              	SUB	B		; Bits to shift
2753    CD 15 25        	CALL	SCALE		; Shift BCDE
2756    7C              	LD	A,H		; Get combined sign
2757    17              	RLA			; Sign to carry
2758    DC E8 24        	CALL	C,FPROND	; Negative - Round number up
275B    06 00           	LD	B,0		; Zero exponent
275D    DC 01 25        	CALL	C,COMPL		; If negative make positive
2760    E1              	POP	HL		; Restore pointer to number
2761    C9              	RET
2762                    ;
2762    1B              DCBCDE: DEC	DE		; Decrement BCDE
2763    7A              	LD	A,D		; Test LSBs
2764    A3              	AND	E
2765    3C              	INC	A
2766    C0              	RET	NZ		; Exit if LSBs not FFFF
2767    0B              	DEC	BC		; Decrement MSBs
2768    C9              	RET
2769                    ;
2769    21 2C C1        INT:	LD	HL,FPEXP	; Point to exponent
276C    7E              	LD	A,(HL)		; Get exponent
276D    FE 98           	CP	80H+24		; Integer accuracy only?
276F    3A 29 C1        	LD	A,(FPREG)	; Get LSB
2772    D0              	RET	NC		; Yes - Already integer
2773    7E              	LD	A,(HL)		; Get exponent
2774    CD 3E 27        	CALL	FPINT		; F.P to integer
2777    36 98           	LD	(HL),80H+24	; Save 24 bit integer
2779    7B              	LD	A,E		; Get LSB of number
277A    F5              	PUSH	AF		; Save LSB
277B    79              	LD	A,C		; Get MSB of number
277C    17              	RLA			; Sign to carry
277D    CD 9E 24        	CALL	CONPOS		; Set sign of result
2780    F1              	POP	AF		; Restore LSB of number
2781    C9              	RET
2782                    ;
2782    21 00 00        MLDEBC: LD	HL,0		; Clear partial product
2785    78              	LD	A,B		; Test multiplier
2786    B1              	OR	C
2787    C8              	RET	Z		; Return zero if zero
2788    3E 10           	LD	A,16		; 16 bits
278A    29              MLDBLP: ADD	HL,HL		; Shift P.P left
278B    DA C2 1F        	JP	C,BSERR		; ?BS Error if overflow
278E    EB              	EX	DE,HL
278F    29              	ADD	HL,HL		; Shift multiplier left
2790    EB              	EX	DE,HL
2791    D2 98 27        	JP	NC,NOMLAD	; Bit was zero - No add
2794    09              	ADD	HL,BC		; Add multiplicand
2795    DA C2 1F        	JP	C,BSERR		; ?BS Error if overflow
2798    3D              NOMLAD: DEC	A		; Count bits
2799    C2 8A 27        	JP	NZ,MLDBLP	; More
279C    C9              	RET
279D                    ;
279D    FE 2D           ASCTFP: CP	'-'		; Negative?
279F    F5              	PUSH	AF		; Save it and flags
27A0    CA A9 27        	JP	Z,CNVNUM	; Yes - Convert number
27A3    FE 2B           	CP	'+'		; Positive?
27A5    CA A9 27        	JP	Z,CNVNUM	; Yes - Convert number
27A8    2B              	DEC	HL		; DEC 'cos GETCHR INCs
27A9    CD B6 24        CNVNUM: CALL	RESZER		; Set result to zero
27AC    47              	LD	B,A		; Digits after point counter
27AD    57              	LD	D,A		; Sign of exponent
27AE    5F              	LD	E,A		; Exponent of ten
27AF    2F              	CPL
27B0    4F              	LD	C,A		; Before or after point flag
27B1    CD 47 18        MANLP:	CALL	GETCHR		; Get next character
27B4    DA FA 27        	JP	C,ADDIG		; Digit - Add to number
27B7    FE 2E           	CP	'.'
27B9    CA D5 27        	JP	Z,DPOINT	; '.' - Flag point
27BC    FE 45           	CP	'E'
27BE    C2 D9 27        	JP	NZ,CONEXP	; Not 'E' - Scale number
27C1    CD 47 18        	CALL	GETCHR		; Get next character
27C4    CD ED 1D        	CALL	SGNEXP		; Get sign of exponent
27C7    CD 47 18        EXPLP:	CALL	GETCHR		; Get next character
27CA    DA 1C 28        	JP	C,EDIGIT	; Digit - Add to exponent
27CD    14              	INC	D		; Is sign negative?
27CE    C2 D9 27        	JP	NZ,CONEXP	; No - Scale number
27D1    AF              	XOR	A
27D2    93              	SUB	E		; Negate exponent
27D3    5F              	LD	E,A		; And re-save it
27D4    0C              	INC	C		; Flag end of number
27D5    0C              DPOINT: INC	C		; Flag point passed
27D6    CA B1 27        	JP	Z,MANLP		; Zero - Get another digit
27D9    E5              CONEXP: PUSH	HL		; Save code string address
27DA    7B              	LD	A,E		; Get exponent
27DB    90              	SUB	B		; Subtract digits after point
27DC    F4 F2 27        SCALMI: CALL	P,SCALPL	; Positive - Multiply number
27DF    F2 E8 27        	JP	P,ENDCON	; Positive - All done
27E2    F5              	PUSH	AF		; Save number of times to /10
27E3    CD DE 25        	CALL	DIV10		; Divide by 10
27E6    F1              	POP	AF		; Restore count
27E7    3C              	INC	A		; Count divides
27E8                    ;
27E8    C2 DC 27        ENDCON: JP	NZ,SCALMI	; More to do
27EB    D1              	POP	DE		; Restore code string address
27EC    F1              	POP	AF		; Restore sign of number
27ED    CC BF 26        	CALL	Z,INVSGN	; Negative - Negate number
27F0    EB              	EX	DE,HL		; Code string address to HL
27F1    C9              	RET
27F2                    ;
27F2    C8              SCALPL: RET	Z		; Exit if no scaling needed
27F3    F5              MULTEN: PUSH	AF		; Save count
27F4    CD 7F 26        	CALL	MLSP10		; Multiply number by 10
27F7    F1              	POP	AF		; Restore count
27F8    3D              	DEC	A		; Count multiplies
27F9    C9              	RET
27FA                    ;
27FA    D5              ADDIG:	PUSH	DE		; Save sign of exponent
27FB    57              	LD	D,A		; Save digit
27FC    78              	LD	A,B		; Get digits after point
27FD    89              	ADC	A,C		; Add one if after point
27FE    47              	LD	B,A		; Re-save counter
27FF    C5              	PUSH	BC		; Save point flags
2800    E5              	PUSH	HL		; Save code string address
2801    D5              	PUSH	DE		; Save digit
2802    CD 7F 26        	CALL	MLSP10		; Multiply number by 10
2805    F1              	POP	AF		; Restore digit
2806    D6 30           	SUB	'0'		; Make it absolute
2808    CD 11 28        	CALL	RSCALE		; Re-scale number
280B    E1              	POP	HL		; Restore code string address
280C    C1              	POP	BC		; Restore point flags
280D    D1              	POP	DE		; Restore sign of exponent
280E    C3 B1 27        	JP	MANLP		; Get another digit
2811                    ;
2811    CD C7 26        RSCALE: CALL	STAKFP		; Put number on stack
2814    CD A8 26        	CALL	FLGREL		; Digit to add to FPREG
2817    C1              PADD:	POP	BC		; Restore number
2818    D1              	POP	DE
2819    C3 50 24        	JP	FPADD		; Add BCDE to FPREG and return
281C                    ;
281C    7B              EDIGIT: LD	A,E		; Get digit
281D    07              	RLCA			; Times 2
281E    07              	RLCA			; Times 4
281F    83              	ADD	A,E		; Times 5
2820    07              	RLCA			; Times 10
2821    86              	ADD	A,(HL)		; Add next digit
2822    D6 30           	SUB	'0'		; Make it absolute
2824    5F              	LD	E,A		; Save new digit
2825    C3 C7 27        	JP	EXPLP		; Look for another digit
2828                    ;
2828    E5              LINEIN: PUSH	HL		; Save code string address
2829    21 87 13        	LD	HL,INMSG	; Output " in "
282C    CD 8D 21        	CALL	PRS		; Output string at HL
282F    E1              	POP	HL		; Restore code string address
2830    EB              PRNTHL: EX	DE,HL		; Code string address to DE
2831    AF              	XOR	A
2832    06 98           	LD	B,80H+24	; 24 bits
2834    CD AD 26        	CALL	RETINT		; Return the integer
2837    21 8C 21        	LD	HL,PRNUMS	; Print number string
283A    E5              	PUSH	HL		; Save for return
283B    21 2E C1        NUMASC: LD	HL,PBUFF	; Convert number to ASCII
283E    E5              	PUSH	HL		; Save for return
283F    CD 96 26        	CALL	TSTSGN		; Test sign of FPREG
2842    36 20           	LD	(HL),' '	; Space at start
2844    F2 49 28        	JP	P,SPCFST	; Positive - Space to start
2847    36 2D           	LD	(HL),'-'	; '-' sign at start
2849    23              SPCFST: INC	HL		; First byte of number
284A    36 30           	LD	(HL),'0'	; '0' if zero
284C    CA FF 28        	JP	Z,JSTZER	; Return '0' if zero
284F    E5              	PUSH	HL		; Save buffer address
2850    FC BF 26        	CALL	M,INVSGN	; Negate FPREG if negative
2853    AF              	XOR	A		; Zero A
2854    F5              	PUSH	AF		; Save it
2855    CD 05 29        	CALL	RNGTST		; Test number is in range
2858    01 43 91        SIXDIG: LD	BC,9143H	; BCDE - 99999.9
285B    11 F8 4F        	LD	DE,4FF8H
285E    CD 11 27        	CALL	CMPNUM		; Compare numbers
2861    B7              	OR	A
2862    E2 76 28        	JP	PO,INRNG	; > 99999.9 - Sort it out
2865    F1              	POP	AF		; Restore count
2866    CD F3 27        	CALL	MULTEN		; Multiply by ten
2869    F5              	PUSH	AF		; Re-save count
286A    C3 58 28        	JP	SIXDIG		; Test it again
286D                    ;
286D    CD DE 25        GTSIXD: CALL	DIV10		; Divide by 10
2870    F1              	POP	AF		; Get count
2871    3C              	INC	A		; Count divides
2872    F5              	PUSH	AF		; Re-save count
2873    CD 05 29        	CALL	RNGTST		; Test number is in range
2876    CD 3E 24        INRNG:	CALL	ROUND		; Add 0.5 to FPREG
2879    3C              	INC	A
287A    CD 3E 27        	CALL	FPINT		; F.P to integer
287D    CD D7 26        	CALL	FPBCDE		; Move BCDE to FPREG
2880    01 06 03        	LD	BC,0306H	; 1E+06 to 1E-03 range
2883    F1              	POP	AF		; Restore count
2884    81              	ADD	A,C		; 6 digits before point
2885    3C              	INC	A		; Add one
2886    FA 92 28        	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
2889    FE 08           	CP	6+1+1		; More than 999999 ?
288B    D2 92 28        	JP	NC,MAKNUM	; Yes - Do it in 'E' form
288E    3C              	INC	A		; Adjust for exponent
288F    47              	LD	B,A		; Exponent of number
2890    3E 02           	LD	A,2		; Make it zero after
2892                    ;
2892    3D              MAKNUM: DEC	A		; Adjust for digits to do
2893    3D              	DEC	A
2894    E1              	POP	HL		; Restore buffer address
2895    F5              	PUSH	AF		; Save count
2896    11 18 29        	LD	DE,POWERS	; Powers of ten
2899    05              	DEC	B		; Count digits before point
289A    C2 A3 28        	JP	NZ,DIGTXT	; Not zero - Do number
289D    36 2E           	LD	(HL),'.'	; Save point
289F    23              	INC	HL		; Move on
28A0    36 30           	LD	(HL),'0'	; Save zero
28A2    23              	INC	HL		; Move on
28A3    05              DIGTXT: DEC	B		; Count digits before point
28A4    36 2E           	LD	(HL),'.'	; Save point in case
28A6    CC EC 26        	CALL	Z,INCHL		; Last digit - move on
28A9    C5              	PUSH	BC		; Save digits before point
28AA    E5              	PUSH	HL		; Save buffer address
28AB    D5              	PUSH	DE		; Save powers of ten
28AC    CD E2 26        	CALL	BCDEFP		; Move FPREG to BCDE
28AF    E1              	POP	HL		; Powers of ten table
28B0    06 2F           	LD	B, '0'-1	; ASCII '0' - 1
28B2    04              TRYAGN: INC	B		; Count subtractions
28B3    7B              	LD	A,E		; Get LSB
28B4    96              	SUB	(HL)		; Subtract LSB
28B5    5F              	LD	E,A		; Save LSB
28B6    23              	INC	HL
28B7    7A              	LD	A,D		; Get NMSB
28B8    9E              	SBC	A,(HL)		; Subtract NMSB
28B9    57              	LD	D,A		; Save NMSB
28BA    23              	INC	HL
28BB    79              	LD	A,C		; Get MSB
28BC    9E              	SBC	A,(HL)		; Subtract MSB
28BD    4F              	LD	C,A		; Save MSB
28BE    2B              	DEC	HL		; Point back to start
28BF    2B              	DEC	HL
28C0    D2 B2 28        	JP	NC,TRYAGN	; No overflow - Try again
28C3    CD F5 24        	CALL	PLUCDE		; Restore number
28C6    23              	INC	HL		; Start of next number
28C7    CD D7 26        	CALL	FPBCDE		; Move BCDE to FPREG
28CA    EB              	EX	DE,HL		; Save point in table
28CB    E1              	POP	HL		; Restore buffer address
28CC    70              	LD	(HL),B		; Save digit in buffer
28CD    23              	INC	HL		; And move on
28CE    C1              	POP	BC		; Restore digit count
28CF    0D              	DEC	C		; Count digits
28D0    C2 A3 28        	JP	NZ,DIGTXT	; More - Do them
28D3    05              	DEC	B		; Any decimal part?
28D4    CA E3 28        	JP	Z,DOEBIT	; No - Do 'E' bit
28D7    2B              SUPTLZ: DEC	HL		; Move back through buffer
28D8    7E              	LD	A,(HL)		; Get character
28D9    FE 30           	CP	'0'		; '0' character?
28DB    CA D7 28        	JP	Z,SUPTLZ	; Yes - Look back for more
28DE    FE 2E           	CP	'.'		; A decimal point?
28E0    C4 EC 26        	CALL	NZ,INCHL	; Move back over digit
28E3                    ;
28E3    F1              DOEBIT: POP	AF		; Get 'E' flag
28E4    CA 02 29        	JP	Z,NOENED	; No 'E' needed - End buffer
28E7    36 45           	LD	(HL),'E'	; Put 'E' in buffer
28E9    23              	INC	HL		; And move on
28EA    36 2B           	LD	(HL),'+'	; Put '+' in buffer
28EC    F2 F3 28        	JP	P,OUTEXP	; Positive - Output exponent
28EF    36 2D           	LD	(HL),'-'	; Put '-' in buffer
28F1    2F              	CPL			; Negate exponent
28F2    3C              	INC	A
28F3    06 2F           OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
28F5    04              EXPTEN: INC	B		; Count subtractions
28F6    D6 0A           	SUB	10		; Tens digit
28F8    D2 F5 28        	JP	NC,EXPTEN	; More to do
28FB    C6 3A           	ADD	A,'0'+10	; Restore and make ASCII
28FD    23              	INC	HL		; Move on
28FE    70              	LD	(HL),B		; Save MSB of exponent
28FF    23              JSTZER: INC	HL		;
2900    77              	LD	(HL),A		; Save LSB of exponent
2901    23              	INC	HL
2902    71              NOENED: LD	(HL),C		; Mark end of buffer
2903    E1              	POP	HL		; Restore code string address
2904    C9              	RET
2905                    ;
2905    01 74 94        RNGTST: LD	BC,9474H	; BCDE = 999999.
2908    11 F7 23        	LD	DE,23F7H
290B    CD 11 27        	CALL	CMPNUM		; Compare numbers
290E    B7              	OR	A
290F    E1              	POP	HL		; Return address to HL
2910    E2 6D 28        	JP	PO,GTSIXD	; Too big - Divide by ten
2913    E9              	JP	(HL)		; Otherwise return to caller
2914                    ;
2914    00 00 00 80     HALF:	DB	00H,00H,00H,80H	; 0.5
2918                    ;
2918    A0 86 01        POWERS: DB	0A0H,086H,001H	; 100000
291B    10 27 00        	DB	010H,027H,000H	; 10000
291E    E8 03 00        	DB	0E8H,003H,000H	; 1000
2921    64 00 00        	DB	064H,000H,000H	; 100
2924    0A 00 00        	DB	00AH,000H,000H	; 10
2927    01 00 00        	DB	001H,000H,000H	; 1
292A                    ;
292A    21 BF 26        NEGAFT: LD	HL,INVSGN	; Negate result
292D    E3              	EX	(SP),HL		; To be done after caller
292E    E9              	JP	(HL)		; Return to caller
292F                    ;
292F    CD C7 26        SQR:	CALL	STAKFP		; Put value on stack
2932    21 14 29        	LD	HL,HALF		; Set power to 1/2
2935    CD D4 26        	CALL	PHLTFP		; Move 1/2 to FPREG
2938                    ;
2938    C1              POWER:	POP	BC		; Get base
2939    D1              	POP	DE
293A    CD 96 26        	CALL	TSTSGN		; Test sign of power
293D    78              	LD	A,B		; Get exponent of base
293E    CA 7D 29        	JP	Z,EXP		; Make result 1 if zero
2941    F2 48 29        	JP	P,POWER1	; Positive base - Ok
2944    B7              	OR	A		; Zero to negative power?
2945    CA F2 13        	JP	Z,DZERR		; Yes - ?/0 Error
2948    B7              POWER1: OR	A		; Base zero?
2949    CA B7 24        	JP	Z,SAVEXP	; Yes - Return zero
294C    D5              	PUSH	DE		; Save base
294D    C5              	PUSH	BC
294E    79              	LD	A,C		; Get MSB of base
294F    F6 7F           	OR	01111111B	; Get sign status
2951    CD E2 26        	CALL	BCDEFP		; Move power to BCDE
2954    F2 65 29        	JP	P,POWER2	; Positive base - Ok
2957    D5              	PUSH	DE		; Save power
2958    C5              	PUSH	BC
2959    CD 69 27        	CALL	INT		; Get integer of power
295C    C1              	POP	BC		; Restore power
295D    D1              	POP	DE
295E    F5              	PUSH	AF		; MSB of base
295F    CD 11 27        	CALL	CMPNUM		; Power an integer?
2962    E1              	POP	HL		; Restore MSB of base
2963    7C              	LD	A,H		; but don't affect flags
2964    1F              	RRA			; Exponent odd or even?
2965    E1              POWER2: POP	HL		; Restore MSB and exponent
2966    22 2B C1        	LD	(FPREG+2),HL	; Save base in FPREG
2969    E1              	POP	HL		; LSBs of base
296A    22 29 C1        	LD	(FPREG),HL	; Save in FPREG
296D    DC 2A 29        	CALL	C,NEGAFT	; Odd power - Negate result
2970    CC BF 26        	CALL	Z,INVSGN	; Negative base - Negate it
2973    D5              	PUSH	DE		; Save power
2974    C5              	PUSH	BC
2975    CD 4A 25        	CALL	LOG		; Get LOG of base
2978    C1              	POP	BC		; Restore power
2979    D1              	POP	DE
297A    CD 8B 25        	CALL	FPMULT		; Multiply LOG by power
297D                    ;
297D    CD C7 26        EXP:	CALL	STAKFP		; Put value on stack
2980    01 38 81        	LD	BC,08138H	; BCDE = 1/Ln(2)
2983    11 3B AA        	LD	DE,0AA3BH
2986    CD 8B 25        	CALL	FPMULT		; Multiply value by 1/LN(2)
2989    3A 2C C1        	LD	A,(FPEXP)	; Get exponent
298C    FE 88           	CP	80H+8		; Is it in range?
298E    D2 72 26        	JP	NC,OVTST1	; No - Test for overflow
2991    CD 69 27        	CALL	INT		; Get INT of FPREG
2994    C6 80           	ADD	A,80H		; For excess 128
2996    C6 02           	ADD	A,2		; Exponent > 126?
2998    DA 72 26        	JP	C,OVTST1	; Yes - Test for overflow
299B    F5              	PUSH	AF		; Save scaling factor
299C    21 39 25        	LD	HL,UNITY	; Point to 1.
299F    CD 41 24        	CALL	ADDPHL		; Add 1 to FPREG
29A2    CD 82 25        	CALL	MULLN2		; Multiply by LN(2)
29A5    F1              	POP	AF		; Restore scaling factor
29A6    C1              	POP	BC		; Restore exponent
29A7    D1              	POP	DE
29A8    F5              	PUSH	AF		; Save scaling factor
29A9    CD 4D 24        	CALL	SUBCDE		; Subtract exponent from FPREG
29AC    CD BF 26        	CALL	INVSGN		; Negate result
29AF    21 BD 29        	LD	HL,EXPTAB	; Coefficient table
29B2    CD ED 29        	CALL	SMSER1		; Sum the series
29B5    11 00 00        	LD	DE,0		; Zero LSBs
29B8    C1              	POP	BC		; Scaling factor
29B9    4A              	LD	C,D		; Zero MSB
29BA    C3 8B 25        	JP	FPMULT		; Scale result to correct value
29BD                    ;
29BD    08              EXPTAB: DB	8			; Table used by EXP
29BE    40 2E 94 74     	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
29C2    70 4F 2E 77     	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
29C6    6E 02 88 7A     	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
29CA    E6 A0 2A 7C     	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
29CE    50 AA AA 7E     	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
29D2    FF FF 7F 7F     	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
29D6    00 00 80 81     	DB	000H,000H,080H,081H	; -1/1! (-1/1)
29DA    00 00 00 81     	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
29DE                    ;
29DE    CD C7 26        SUMSER: CALL	STAKFP		; Put FPREG on stack
29E1    11 89 25        	LD	DE,MULT		; Multiply by "X"
29E4    D5              	PUSH	DE		; To be done after
29E5    E5              	PUSH	HL		; Save address of table
29E6    CD E2 26        	CALL	BCDEFP		; Move FPREG to BCDE
29E9    CD 8B 25        	CALL	FPMULT		; Square the value
29EC    E1              	POP	HL		; Restore address of table
29ED    CD C7 26        SMSER1: CALL	STAKFP		; Put value on stack
29F0    7E              	LD	A,(HL)		; Get number of coefficients
29F1    23              	INC	HL		; Point to start of table
29F2    CD D4 26        	CALL	PHLTFP		; Move coefficient to FPREG
29F5    06              	DB	06H		; Skip "POP AF"
29F6    F1              SUMLP:	POP	AF		; Restore count
29F7    C1              	POP	BC		; Restore number
29F8    D1              	POP	DE
29F9    3D              	DEC	A		; Cont coefficients
29FA    C8              	RET	Z		; All done
29FB    D5              	PUSH	DE		; Save number
29FC    C5              	PUSH	BC
29FD    F5              	PUSH	AF		; Save count
29FE    E5              	PUSH	HL		; Save address in table
29FF    CD 8B 25        	CALL	FPMULT		; Multiply FPREG by BCDE
2A02    E1              	POP	HL		; Restore address in table
2A03    CD E5 26        	CALL	LOADFP		; Number at HL to BCDE
2A06    E5              	PUSH	HL		; Save address in table
2A07    CD 50 24        	CALL	FPADD		; Add coefficient to FPREG
2A0A    E1              	POP	HL		; Restore address in table
2A0B    C3 F6 29        	JP	SUMLP		; More coefficients
2A0E                    ;
2A0E    CD 96 26        RND:	CALL	TSTSGN		; Test sign of FPREG
2A11    21 5E C0        	LD	HL,SEED+2	; Random number seed
2A14    FA 6F 2A        	JP	M,RESEED	; Negative - Re-seed
2A17    21 7F C0        	LD	HL,LSTRND	; Last random number
2A1A    CD D4 26        	CALL	PHLTFP		; Move last RND to FPREG
2A1D    21 5E C0        	LD	HL,SEED+2	; Random number seed
2A20    C8              	RET	Z		; Return if RND(0)
2A21    86              	ADD	A,(HL)		; Add (SEED)+2)
2A22    E6 07           	AND	00000111B	; 0 to 7
2A24    06 00           	LD	B,0
2A26    77              	LD	(HL),A		; Re-save seed
2A27    23              	INC	HL		; Move to coefficient table
2A28    87              	ADD	A,A		; 4 bytes
2A29    87              	ADD	A,A		; per entry
2A2A    4F              	LD	C,A		; BC = Offset into table
2A2B    09              	ADD	HL,BC		; Point to coefficient
2A2C    CD E5 26        	CALL	LOADFP		; Coefficient to BCDE
2A2F    CD 8B 25        	CALL	FPMULT	;	; Multiply FPREG by coefficient
2A32    3A 5D C0        	LD	A,(SEED+1)	; Get (SEED+1)
2A35    3C              	INC	A		; Add 1
2A36    E6 03           	AND	00000011B	; 0 to 3
2A38    06 00           	LD	B,0
2A3A    FE 01           	CP	1		; Is it zero?
2A3C    88              	ADC	A,B		; Yes - Make it 1
2A3D    32 5D C0        	LD	(SEED+1),A	; Re-save seed
2A40    21 73 2A        	LD	HL,RNDTAB-4	; Addition table
2A43    87              	ADD	A,A		; 4 bytes
2A44    87              	ADD	A,A		; per entry
2A45    4F              	LD	C,A		; BC = Offset into table
2A46    09              	ADD	HL,BC		; Point to value
2A47    CD 41 24        	CALL	ADDPHL		; Add value to FPREG
2A4A    CD E2 26        RND1:	CALL	BCDEFP		; Move FPREG to BCDE
2A4D    7B              	LD	A,E		; Get LSB
2A4E    59              	LD	E,C		; LSB = MSB
2A4F    EE 4F           	XOR	01001111B	; Fiddle around
2A51    4F              	LD	C,A		; New MSB
2A52    36 80           	LD	(HL),80H	; Set exponent
2A54    2B              	DEC	HL		; Point to MSB
2A55    46              	LD	B,(HL)		; Get MSB
2A56    36 80           	LD	(HL),80H	; Make value -0.5
2A58    21 5C C0        	LD	HL,SEED		; Random number seed
2A5B    34              	INC	(HL)		; Count seed
2A5C    7E              	LD	A,(HL)		; Get seed
2A5D    D6 AB           	SUB	171		; Do it modulo 171
2A5F    C2 66 2A        	JP	NZ,RND2		; Non-zero - Ok
2A62    77              	LD	(HL),A		; Zero seed
2A63    0C              	INC	C		; Fillde about
2A64    15              	DEC	D		; with the
2A65    1C              	INC	E		; number
2A66    CD A1 24        RND2:	CALL	BNORM		; Normalise number
2A69    21 7F C0        	LD	HL,LSTRND	; Save random number
2A6C    C3 EE 26        	JP	FPTHL		; Move FPREG to last and return
2A6F                    ;
2A6F    77              RESEED: LD	(HL),A		; Re-seed random numbers
2A70    2B              	DEC	HL
2A71    77              	LD	(HL),A
2A72    2B              	DEC	HL
2A73    77              	LD	(HL),A
2A74    C3 4A 2A        	JP	RND1		; Return RND seed
2A77                    ;
2A77    68 B1 46 68     RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
2A7B    99 E9 92 69     	DB	099H,0E9H,092H,069H
2A7F    10 D1 75 68     	DB	010H,0D1H,075H,068H
2A83                    ;
2A83    21 CD 2A        COS:	LD	HL,HALFPI	; Point to PI/2
2A86    CD 41 24        	CALL	ADDPHL		; Add it to PPREG
2A89    CD C7 26        SIN:	CALL	STAKFP		; Put angle on stack
2A8C    01 49 83        	LD	BC,8349H	; BCDE = 2 PI
2A8F    11 DB 0F        	LD	DE,0FDBH
2A92    CD D7 26        	CALL	FPBCDE		; Move 2 PI to FPREG
2A95    C1              	POP	BC		; Restore angle
2A96    D1              	POP	DE
2A97    CD EC 25        	CALL	DVBCDE		; Divide angle by 2 PI
2A9A    CD C7 26        	CALL	STAKFP		; Put it on stack
2A9D    CD 69 27        	CALL	INT		; Get INT of result
2AA0    C1              	POP	BC		; Restore number
2AA1    D1              	POP	DE
2AA2    CD 4D 24        	CALL	SUBCDE		; Make it 0 <= value < 1
2AA5    21 D1 2A        	LD	HL,QUARTR	; Point to 0.25
2AA8    CD 47 24        	CALL	SUBPHL		; Subtract value from 0.25
2AAB    CD 96 26        	CALL	TSTSGN		; Test sign of value
2AAE    37              	SCF			; Flag positive
2AAF    F2 B9 2A        	JP	P,SIN1		; Positive - Ok
2AB2    CD 3E 24        	CALL	ROUND		; Add 0.5 to value
2AB5    CD 96 26        	CALL	TSTSGN		; Test sign of value
2AB8    B7              	OR	A		; Flag negative
2AB9    F5              SIN1:	PUSH	AF		; Save sign
2ABA    F4 BF 26        	CALL	P,INVSGN	; Negate value if positive
2ABD    21 D1 2A        	LD	HL,QUARTR	; Point to 0.25
2AC0    CD 41 24        	CALL	ADDPHL		; Add 0.25 to value
2AC3    F1              	POP	AF		; Restore sign
2AC4    D4 BF 26        	CALL	NC,INVSGN	; Negative - Make positive
2AC7    21 D5 2A        	LD	HL,SINTAB	; Coefficient table
2ACA    C3 DE 29        	JP	SUMSER		; Evaluate sum of series
2ACD                    ;
2ACD    DB 0F 49 81     HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
2AD1                    ;
2AD1    00 00 00 7F     QUARTR: DB	000H,000H,000H,07FH	; 0.25
2AD5                    ;
2AD5    05              SINTAB: DB	5			; Table used by SIN
2AD6    BA D7 1E 86     	DB	0BAH,0D7H,01EH,086H	; 39.711
2ADA    64 26 99 87     	DB	064H,026H,099H,087H	;-76.575
2ADE    58 34 23 87     	DB	058H,034H,023H,087H	; 81.602
2AE2    E0 5D A5 86     	DB	0E0H,05DH,0A5H,086H	;-41.342
2AE6    DA 0F 49 83     	DB	0DAH,00FH,049H,083H	; 6.2832
2AEA                    ;
2AEA    CD C7 26        TAN:	CALL	STAKFP		; Put angle on stack
2AED    CD 89 2A        	CALL	SIN		; Get SIN of angle
2AF0    C1              	POP	BC		; Restore angle
2AF1    E1              	POP	HL
2AF2    CD C7 26        	CALL	STAKFP		; Save SIN of angle
2AF5    EB              	EX	DE,HL		; BCDE = Angle
2AF6    CD D7 26        	CALL	FPBCDE		; Angle to FPREG
2AF9    CD 83 2A        	CALL	COS		; Get COS of angle
2AFC    C3 EA 25        	JP	DIV		; TAN = SIN / COS
2AFF                    ;
2AFF    CD 96 26        ATN:	CALL	TSTSGN		; Test sign of value
2B02    FC 2A 29        	CALL	M,NEGAFT	; Negate result after if -ve
2B05    FC BF 26        	CALL	M,INVSGN	; Negate value if -ve
2B08    3A 2C C1        	LD	A,(FPEXP)	; Get exponent
2B0B    FE 81           	CP	81H		; Number less than 1?
2B0D    DA 1C 2B        	JP	C,ATN1		; Yes - Get arc tangnt
2B10    01 00 81        	LD	BC,8100H	; BCDE = 1
2B13    51              	LD	D,C
2B14    59              	LD	E,C
2B15    CD EC 25        	CALL	DVBCDE		; Get reciprocal of number
2B18    21 47 24        	LD	HL,SUBPHL	; Sub angle from PI/2
2B1B    E5              	PUSH	HL		; Save for angle > 1
2B1C    21 26 2B        ATN1:	LD	HL,ATNTAB	; Coefficient table
2B1F    CD DE 29        	CALL	SUMSER		; Evaluate sum of series
2B22    21 CD 2A        	LD	HL,HALFPI	; PI/2 - angle in case > 1
2B25    C9              	RET			; Number > 1 - Sub from PI/2
2B26                    ;
2B26    09              ATNTAB: DB	9			; Table used by ATN
2B27    4A D7 3B 78     	DB	04AH,0D7H,03BH,078H	; 1/17
2B2B    02 6E 84 7B     	DB	002H,06EH,084H,07BH	;-1/15
2B2F    FE C1 2F 7C     	DB	0FEH,0C1H,02FH,07CH	; 1/13
2B33    74 31 9A 7D     	DB	074H,031H,09AH,07DH	;-1/11
2B37    84 3D 5A 7D     	DB	084H,03DH,05AH,07DH	; 1/9
2B3B    C8 7F 91 7E     	DB	0C8H,07FH,091H,07EH	;-1/7
2B3F    E4 BB 4C 7E     	DB	0E4H,0BBH,04CH,07EH	; 1/5
2B43    6C AA AA 7F     	DB	06CH,0AAH,0AAH,07FH	;-1/3
2B47    00 00 00 81     	DB	000H,000H,000H,081H	; 1/1
2B4B                    ;
2B4B
2B4B    C9              ARET:	RET			; A RETurn instruction
2B4C                    ;
2B4C    D7              GETINP: RST	10H		;input a character
2B4D    C9              	RET
2B4E                    ;
2B4E                    CLS:
2B4E    3E 0C           	LD	A,CS		; ASCII Clear screen
2B50    C3 84 2C        	JP	MONOUT		; Output character
2B53                    ;
2B53    CD 15 24        WIDTH:	CALL	GETINT		; Get integer 0-255
2B56    7B              	LD	A,E		; Width to A
2B57    32 87 C0        	LD	(LWIDTH),A	; Set width
2B5A    C9              	RET
2B5B                    ;
2B5B    CD B4 1C        LINES:	CALL	GETNUM		; Get a number
2B5E    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
2B61    ED 53 8B C0     	LD	(LINESC),DE	; Set lines counter
2B65    ED 53 8D C0     	LD	(LINESN),DE	; Set lines number
2B69    C9              	RET
2B6A                    ;
2B6A    CD F9 18        DEEK:	CALL	DEINT		; Get integer -32768 to 32767
2B6D    D5              	PUSH	DE		; Save number
2B6E    E1              	POP	HL		; Number to HL
2B6F    46              	LD	B,(HL)		; Get LSB of contents
2B70    23              	INC	HL
2B71    7E              	LD	A,(HL)		; Get MSB of contents
2B72    C3 6F 20        	JP	ABPASS		; Return integer AB
2B75                    ;
2B75    CD B4 1C        DOKE:	CALL	GETNUM		; Get a number
2B78    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
2B7B    D5              	PUSH	DE		; Save address
2B7C    CD BD 16        	CALL	CHKSYN		; Make sure ',' follows
2B7F    2C              	DB	','
2B80    CD B4 1C        	CALL	GETNUM		; Get a number
2B83    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
2B86    E3              	EX	(SP),HL		; Save value,get address
2B87    73              	LD	(HL),E		; Save LSB of value
2B88    23              	INC	HL
2B89    72              	LD	(HL),D		; Save MSB of value
2B8A    E1              	POP	HL		; Restore code string address
2B8B    C9              	RET
2B8C                    ;
2B8C
2B8C                    ; HEX$(nn) Convert 16 bit number to Hexadecimal string
2B8C                    ;
2B8C    CD B7 1C        HEX: 	CALL	TSTNUM		; Verify it's a number
2B8F    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
2B92    C5              	PUSH	BC		; Save contents of BC
2B93    21 2E C1        	LD	HL,PBUFF
2B96    7A              	LD	A,D		; Get high order into A
2B97    FE 00           	CP	0
2B99    28 0C           	JR	Z,HEX2		; Skip output if both high digits are zero
2B9B    CD C4 2B        	CALL	BYT2ASC		; Convert D to ASCII
2B9E    78              	LD	A,B
2B9F    FE 30           	CP	'0'
2BA1    28 02           	JR	Z,HEX1		; Don't store high digit if zero
2BA3    70              	LD	(HL),B		; Store it to PBUFF
2BA4    23              	INC	HL		; Next location
2BA5    71              HEX1:	LD	(HL),C		; Store C to PBUFF+1
2BA6    23              	INC	HL		; Next location
2BA7    7B              HEX2:	LD	A,E		; Get lower byte
2BA8    CD C4 2B        	CALL	BYT2ASC		; Convert E to ASCII
2BAB    7A              	LD	A,D
2BAC    FE 00           	CP	0
2BAE    20 05           	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
2BB0    78              	LD	A,B
2BB1    FE 30           	CP	'0'		; If high digit of lower byte is zero then don't print
2BB3    28 02           	JR	Z,HEX4
2BB5    70              HEX3:	LD	(HL),B		; to PBUFF+2
2BB6    23              	INC	HL		; Next location
2BB7    71              HEX4:	LD	(HL),C		; to PBUFF+3
2BB8    23              	INC	HL		; PBUFF+4 to zero
2BB9    AF              	XOR	A		; Terminating character
2BBA    77              	LD	(HL),A		; Store zero to terminate
2BBB    23              	INC	HL		; Make sure PBUFF is terminated
2BBC    77              	LD	(HL),A		; Store the double zero there
2BBD    C1              	POP	BC		; Get BC back
2BBE    21 2E C1        	LD	HL,PBUFF	; Reset to start of PBUFF
2BC1    C3 1D 21        	JP	STR1		; Convert the PBUFF to a string and return it
2BC4                    ;
2BC4    47              BYT2ASC: LD	B,A		; Save original value
2BC5    E6 0F           	AND	0FH		; Strip off upper nybble
2BC7    FE 0A           	CP	0AH		; 0-9?
2BC9    38 02           	JR	C,ADD30		; If A-F, add 7 more
2BCB    C6 07           	ADD	A,07H		; Bring value up to ASCII A-F
2BCD    C6 30           ADD30:	ADD	A,30H		; And make ASCII
2BCF    4F              	LD	C,A		; Save converted char to C
2BD0    78              	LD	A,B		; Retrieve original value
2BD1    0F              	RRCA			; and Rotate it right
2BD2    0F              	RRCA
2BD3    0F              	RRCA
2BD4    0F              	RRCA
2BD5    E6 0F           	AND	0FH		; Mask off upper nybble
2BD7    FE 0A           	CP	0AH		; 0-9? < A hex?
2BD9    38 02           	JR	C,ADD301	; Skip Add 7
2BDB    C6 07           	ADD	A,07H		; Bring it up to ASCII A-F
2BDD    C6 30           ADD301:	ADD	A,30H		; And make it full ASCII
2BDF    47              	LD	B,A		; Store high order byte
2BE0    C9              	RET
2BE1                    ;
2BE1                    ; Convert "&Hnnnn" to FPREG
2BE1                    ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
2BE1                    ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
2BE1    EB              HEXTFP:	EX	DE,HL		; Move code string pointer to DE
2BE2    21 00 00        	LD	HL,0000H	; Zero out the value
2BE5    CD FA 2B        	CALL	GETHEX		; Check the number for valid hex
2BE8    DA 1A 2C        	JP	C,HXERR		; First value wasn't hex, HX error
2BEB    18 05           	JR	HEXLP1		; Convert first character
2BED    CD FA 2B        HEXLP:	CALL	GETHEX		; Get second and addtional characters
2BF0    38 1F           	JR	C,HEXIT		; Exit if not a hex character
2BF2    29              HEXLP1:	ADD	HL,HL		; Rotate 4 bits to the left
2BF3    29              	ADD	HL,HL
2BF4    29              	ADD	HL,HL
2BF5    29              	ADD	HL,HL
2BF6    B5              	OR	L		; Add in D0-D3 into L
2BF7    6F              	LD	L,A		; Save new value
2BF8    18 F3           	JR	HEXLP		; And continue until all hex characters are in
2BFA                    ;
2BFA    13              GETHEX:	INC	DE		; Next location
2BFB    1A              	LD	A,(DE)		; Load character at pointer
2BFC    FE 20           	CP	' '
2BFE    CA FA 2B        	JP	Z,GETHEX	; Skip spaces
2C01    D6 30           	SUB	30H		; Get absolute value
2C03    D8              	RET	C		; < "0", error
2C04    FE 0A           	CP	0AH
2C06    38 05           	JR	C,NOSUB7	; Is already in the range 0-9
2C08    D6 07           	SUB	07H		; Reduce to A-F
2C0A    FE 0A           	CP	0AH		; Value should be $0A-$0F at this point
2C0C    D8              	RET	C		; CY set if was :		; < = > ? @
2C0D    FE 10           NOSUB7:	CP	10H		; > Greater than "F"?
2C0F    3F              	CCF
2C10    C9              	RET			; CY set if it wasn't valid hex
2C11
2C11    EB              HEXIT:	EX	DE,HL		; Value into DE, Code string into HL
2C12    7A              	LD	A,D		; Load DE into AC
2C13    4B              	LD	C,E		; For prep to
2C14    E5              	PUSH	HL
2C15    CD 6E 20        	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
2C18    E1              	POP	HL
2C19    C9              	RET
2C1A                    ;
2C1A    1E 26           HXERR:	LD	E,HX		; ?HEX Error
2C1C    C3 03 14        	JP	ERROR_
2C1F                    ;
2C1F                    ; BIN$(NN) Convert integer to a 1-16 char binary string
2C1F    CD B7 1C        BIN:	CALL	TSTNUM		; Verify it's a number
2C22    CD F9 18        	CALL	DEINT		; Get integer -32768 to 32767
2C25    C5              BIN2:	PUSH	BC		; Save contents of BC
2C26    21 2E C1        	LD	HL,PBUFF
2C29    06 11           	LD	B,17		; One higher than max char count
2C2B                    ZEROSUP:			; Suppress leading zeros
2C2B    05              	DEC	B		; Max 16 chars
2C2C    78              	LD	A,B
2C2D    FE 01           	CP	01H
2C2F    28 08           	JR	Z,BITOUT	; Always output at least one character
2C31    CB 13           	RL	E
2C33    CB 12           	RL	D
2C35    30 F4           	JR	NC,ZEROSUP
2C37    18 04           	JR	BITOUT2
2C39                    BITOUT:
2C39    CB 13           	RL	E
2C3B    CB 12           	RL	D		; Top bit now in carry
2C3D                    BITOUT2:
2C3D    3E 30           	LD	A,'0'		; Char for '0'
2C3F    CE 00           	ADC	A,0		; If carry set then '0' --> '1'
2C41    77              	LD	(HL),A
2C42    23              	INC	HL
2C43    05              	DEC	B
2C44    20 F3           	JR	NZ,BITOUT
2C46    AF              	XOR	A		; Terminating character
2C47    77              	LD	(HL),A		; Store zero to terminate
2C48    23              	INC	HL		; Make sure PBUFF is terminated
2C49    77              	LD	(HL),A		; Store the double zero there
2C4A    C1              	POP	BC
2C4B    21 2E C1        	LD	HL,PBUFF
2C4E    C3 1D 21        	JP	STR1
2C51                    ;
2C51                    ; Convert "&Bnnnn" to FPREG
2C51                    ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
2C51    EB              BINTFP: EX	DE,HL		; Move code string pointer to DE
2C52    21 00 00        	LD	HL,0000H	; Zero out the value
2C55    CD 6E 2C        	CALL	CHKBIN		; Check the number for valid bin
2C58    DA 7C 2C        	JP	C,BINERR	; First value wasn't bin, HX error
2C5B    D6 30           BINIT:	SUB	'0'
2C5D    29              	ADD	HL,HL		; Rotate HL left
2C5E    B5              	OR	L
2C5F    6F              	LD	L,A
2C60    CD 6E 2C        	CALL	CHKBIN		; Get second and addtional characters
2C63    30 F6           	JR	NC,BINIT	; Process if a bin character
2C65    EB              	EX	DE,HL		; Value into DE, Code string into HL
2C66    7A              	LD	A,D		; Load DE into AC
2C67    4B              	LD	C,E		; For prep to
2C68    E5              	PUSH	HL
2C69    CD 6E 20        	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
2C6C    E1              	POP	HL
2C6D    C9              	RET
2C6E                    ;
2C6E                    ; Char is in A, NC if char is 0 or 1
2C6E    13              CHKBIN: INC	DE
2C6F    1A              	LD	A,(DE)
2C70    FE 20           	CP	' '
2C72    CA 6E 2C        	JP	Z,CHKBIN	; Skip spaces
2C75    FE 30           	CP	'0'		; Set C if < '0'
2C77    D8              	RET	C
2C78    FE 32           	CP	'2'
2C7A    3F              	CCF			; Set C if > '1'
2C7B    C9              	RET
2C7C                    ;
2C7C    1E 28           BINERR: LD	E,BN		; ?BIN Error
2C7E    C3 03 14        	JP	ERROR_
2C81                    ;
2C81    C3 48 10        JJUMP1: JP	CSTART		; Go and initialise
2C84                    ;
2C84    C3 34 10        MONOUT: JP	TXA		; output a char
2C87                    ;
2C87    C3 03 00        MONITR: JP	UNI_WST		; Restart unimon
2C8A                    ;
2C8A    3E 00           INITST: LD	A,0		; Clear break flag
2C8C    32 92 C0        	LD	(BRKFLG),A
2C8F    C3 4F 10        	JP	INIT
2C92                    ;
2C92    F5              TSTBIT: PUSH	AF		; Save bit mask
2C93    A0              	AND	B		; Get common bits
2C94    C1              	POP	BC		; Restore bit mask
2C95    B8              	CP	B		; Same bit set?
2C96    3E 00           	LD	A,0		; Return 0 in A
2C98    C9              	RET
2C99                    ;
2C99    CD C8 16        OUTNCR: CALL	OUTC		; Output character in A
2C9C    C3 EF 1A        	JP	PRCRLF		; Output CRLF
2C9F
2C9F    FF FF FF FF     	ds	($ & 0FF00H)+100H-$, 0FFH
2CA3    FF FF FF FF
2CA7    FF FF FF FF
2CAB    FF FF FF FF
2CAF    FF FF FF FF
2CB3    FF FF FF FF
2CB7    FF FF FF FF
2CBB    FF FF FF FF
2CBF    FF FF FF FF
2CC3    FF FF FF FF
2CC7    FF FF FF FF
2CCB    FF FF FF FF
2CCF    FF FF FF FF
2CD3    FF FF FF FF
2CD7    FF FF FF FF
2CDB    FF FF FF FF
2CDF    FF FF FF FF
2CE3    FF FF FF FF
2CE7    FF FF FF FF
2CEB    FF FF FF FF
2CEF    FF FF FF FF
2CF3    FF FF FF FF
2CF7    FF FF FF FF
2CFB    FF FF FF FF
2CFF    FF
2D00
